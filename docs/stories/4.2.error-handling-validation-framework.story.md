# Story 4.2: Error Handling & Validation Framework

## Status
Draft

## Story
**As a** developer,
**I want** to implement comprehensive error handling,
**so that** the system gracefully handles failures and provides meaningful feedback.

## Acceptance Criteria
1. Global exception handler for REST API with standard error format
2. Domain validation exceptions with detailed field-level errors
3. Custom exception types for business rule violations
4. Client-side error interceptor with retry logic
5. User-friendly error messages in UI with actionable guidance
6. Logging framework integration (SLF4J/Logback) with correlation IDs
7. Error boundary components in React for graceful UI failures
8. 404, 403, 500 error pages with consistent design

## Tasks / Subtasks
- [ ] Create standard error response format (AC: 1, 2)
  - [ ] Create ApiErrorResponse class in backend/src/main/java/com/invoiceme/common/dto/
    ```java
    public record ApiErrorResponse(
        String timestamp,
        int status,
        String error,
        String message,
        String path,
        String correlationId,
        List<FieldError> fieldErrors
    ) {
        public static record FieldError(
            String field,
            String message,
            Object rejectedValue
        ) {}
    }
    ```
  - [ ] Ensure consistent JSON format across all error responses
  - [ ] Include HTTP status code
  - [ ] Include timestamp in ISO 8601 format
  - [ ] Include request path
  - [ ] Include correlation ID for tracing
  - [ ] Include field-level errors for validation failures
  - [ ] Include user-friendly error message
  - [ ] Don't expose stack traces or internal details in production

- [ ] Implement global exception handler (AC: 1)
  - [ ] Create GlobalExceptionHandler class in backend/src/main/java/com/invoiceme/common/exceptions/
  - [ ] Annotate with @RestControllerAdvice
  - [ ] Handle MethodArgumentNotValidException (validation errors):
    - Extract field errors from BindingResult
    - Map to ApiErrorResponse with field-level details
    - Return 400 Bad Request
  - [ ] Handle ConstraintViolationException (validation errors):
    - Extract constraint violations
    - Map to field errors
    - Return 400 Bad Request
  - [ ] Handle HttpMessageNotReadableException (malformed JSON):
    - Return 400 Bad Request
    - Message: "Malformed request body"
  - [ ] Handle MethodArgumentTypeMismatchException (type errors):
    - Return 400 Bad Request
    - Include parameter name and expected type
  - [ ] Handle all exceptions with correlation ID
  - [ ] Log all exceptions with appropriate level (ERROR for 5xx, WARN for 4xx)
  - [ ] Use MDC for correlation ID propagation

- [ ] Create custom domain exception types (AC: 3)
  - [ ] Create base DomainException class:
    ```java
    public class DomainException extends RuntimeException {
        private final String errorCode;
        private final Map<String, Object> details;

        public DomainException(String message, String errorCode) { ... }
        public DomainException(String message, String errorCode, Map<String, Object> details) { ... }
    }
    ```
  - [ ] Create EntityNotFoundException:
    - Extends DomainException
    - Used when entity not found by ID
    - Error code: "ENTITY_NOT_FOUND"
    - Include entity type and ID in details
  - [ ] Create BusinessRuleViolationException:
    - Extends DomainException
    - Used for business rule violations
    - Error code: "BUSINESS_RULE_VIOLATION"
    - Include rule name and details
  - [ ] Create InvalidStateTransitionException:
    - Extends DomainException
    - Used for invalid invoice state transitions
    - Error code: "INVALID_STATE_TRANSITION"
    - Include current state, attempted state
  - [ ] Create InsufficientBalanceException:
    - Extends DomainException
    - Used when payment exceeds invoice balance
    - Error code: "INSUFFICIENT_BALANCE"
    - Include invoice balance and attempted payment
  - [ ] Create DuplicateEntityException:
    - Extends DomainException
    - Used for uniqueness violations
    - Error code: "DUPLICATE_ENTITY"
    - Include conflicting field and value
  - [ ] Create OptimisticLockException handler:
    - Handle concurrent modification
    - Error code: "CONCURRENT_MODIFICATION"
    - Message: "Resource was modified by another user"

- [ ] Add exception handlers for custom domain exceptions (AC: 1, 3)
  - [ ] Add to GlobalExceptionHandler
  - [ ] Handle EntityNotFoundException:
    - Return 404 Not Found
    - Include entity type in message
  - [ ] Handle BusinessRuleViolationException:
    - Return 400 Bad Request
    - Include business rule details
  - [ ] Handle InvalidStateTransitionException:
    - Return 400 Bad Request
    - Include current and attempted states
  - [ ] Handle InsufficientBalanceException:
    - Return 400 Bad Request
    - Include balance and payment amount
  - [ ] Handle DuplicateEntityException:
    - Return 409 Conflict
    - Include conflicting field
  - [ ] Handle OptimisticLockException:
    - Return 409 Conflict
    - Message: "Resource modified concurrently, please retry"
  - [ ] Each handler creates ApiErrorResponse with specific details

- [ ] Implement domain validation exceptions (AC: 2)
  - [ ] Create ValidationException class:
    ```java
    public class ValidationException extends DomainException {
        private final List<FieldError> fieldErrors;

        public ValidationException(String message, List<FieldError> fieldErrors) { ... }
        public ValidationException(String field, String message) { ... }
    }
    ```
  - [ ] Add to GlobalExceptionHandler:
    - Handle ValidationException
    - Return 400 Bad Request
    - Map field errors to ApiErrorResponse
  - [ ] Use in domain entities for business validation:
    - Invoice line item validation
    - Payment amount validation
    - Customer data validation
  - [ ] Throw ValidationException with field-level details
  - [ ] Examples:
    - "lineItems: At least one line item is required"
    - "amount: Payment amount cannot exceed invoice balance"
    - "email: Email address is invalid"

- [ ] Add authentication and authorization exception handlers (AC: 1)
  - [ ] Handle AuthenticationException:
    - Return 401 Unauthorized
    - Message: "Authentication failed"
    - Don't expose details (security)
  - [ ] Handle AccessDeniedException:
    - Return 403 Forbidden
    - Message: "Access denied"
  - [ ] Handle JwtException:
    - Return 401 Unauthorized
    - Message: "Invalid or expired token"
  - [ ] Handle UsernameNotFoundException:
    - Return 401 Unauthorized
    - Message: "Invalid credentials" (don't reveal username doesn't exist)
  - [ ] Handle BadCredentialsException:
    - Return 401 Unauthorized
    - Message: "Invalid credentials"
  - [ ] Log authentication failures for security monitoring

- [ ] Implement correlation ID tracking (AC: 6)
  - [ ] Create CorrelationIdFilter class:
    ```java
    @Component
    public class CorrelationIdFilter extends OncePerRequestFilter {
        private static final String CORRELATION_ID_HEADER = "X-Correlation-ID";
        private static final String CORRELATION_ID_MDC_KEY = "correlationId";

        @Override
        protected void doFilterInternal(...) {
            String correlationId = request.getHeader(CORRELATION_ID_HEADER);
            if (correlationId == null) {
                correlationId = UUID.randomUUID().toString();
            }
            MDC.put(CORRELATION_ID_MDC_KEY, correlationId);
            response.setHeader(CORRELATION_ID_HEADER, correlationId);
            try {
                filterChain.doFilter(request, response);
            } finally {
                MDC.remove(CORRELATION_ID_MDC_KEY);
            }
        }
    }
    ```
  - [ ] Register filter in SecurityConfig
  - [ ] Include correlation ID in all log statements
  - [ ] Include correlation ID in ApiErrorResponse
  - [ ] Return correlation ID in response header
  - [ ] Document correlation ID for support/debugging

- [ ] Configure logging framework (AC: 6)
  - [ ] Configure Logback in backend/src/main/resources/logback-spring.xml:
    ```xml
    <configuration>
      <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
          <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] [%X{correlationId}] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
      </appender>

      <logger name="com.invoiceme" level="DEBUG"/>
      <logger name="org.springframework.web" level="INFO"/>
      <logger name="org.hibernate.SQL" level="DEBUG"/>
      <logger name="org.hibernate.type.descriptor.sql.BasicBinder" level="TRACE"/>

      <root level="INFO">
        <appender-ref ref="CONSOLE"/>
      </root>
    </configuration>
    ```
  - [ ] Include correlation ID in log pattern
  - [ ] Configure different log levels for dev vs production
  - [ ] Log SQL statements in development
  - [ ] Log request/response in development
  - [ ] Structured logging format for production (JSON)
  - [ ] Configure log rotation and retention
  - [ ] Add file appender for production logs

- [ ] Add request/response logging (AC: 6)
  - [ ] Create RequestResponseLoggingFilter:
    ```java
    @Component
    public class RequestResponseLoggingFilter extends OncePerRequestFilter {
        private static final Logger logger = LoggerFactory.getLogger(RequestResponseLoggingFilter.class);

        @Override
        protected void doFilterInternal(...) {
            long startTime = System.currentTimeMillis();
            logger.info("Request: {} {}", request.getMethod(), request.getRequestURI());

            try {
                filterChain.doFilter(request, response);
            } finally {
                long duration = System.currentTimeMillis() - startTime;
                logger.info("Response: {} {} - Status: {} - Duration: {}ms",
                    request.getMethod(), request.getRequestURI(), response.getStatus(), duration);
            }
        }
    }
    ```
  - [ ] Log HTTP method, URI, status code, duration
  - [ ] Include correlation ID in logs
  - [ ] Don't log sensitive data (passwords, tokens)
  - [ ] Use INFO level for successful requests
  - [ ] Use WARN level for 4xx errors
  - [ ] Use ERROR level for 5xx errors
  - [ ] Configure filter to exclude health check endpoints

- [ ] Add validation annotations to DTOs (AC: 2)
  - [ ] Add to CreateCustomerDTO:
    ```java
    public record CreateCustomerDTO(
        @NotBlank(message = "Name is required")
        @Size(max = 255, message = "Name must not exceed 255 characters")
        String name,

        @NotBlank(message = "Email is required")
        @Email(message = "Email must be valid")
        String email,

        @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Phone number must be valid")
        String phone,

        @Size(max = 500, message = "Address must not exceed 500 characters")
        String address
    ) {}
    ```
  - [ ] Add to CreateInvoiceDTO:
    - @NotNull for customerId
    - @NotEmpty for lineItems
    - @Valid for nested lineItems
    - @FutureOrPresent for dueDate
    - @Size constraints for text fields
  - [ ] Add to LineItemDTO:
    - @NotBlank for description
    - @Positive for quantity
    - @Positive for unitPrice
    - @Min(0) @Max(1) for discountPercent
    - @Min(0) @Max(1) for taxRate
  - [ ] Add to RecordPaymentDTO:
    - @NotNull for invoiceId
    - @Positive for amount
    - @NotNull for paymentMethod
    - @NotBlank for reference
    - @PastOrPresent for paymentDate
  - [ ] Enable validation with @Valid in controller methods
  - [ ] Custom validators for business rules if needed

- [ ] Create frontend error interceptor (AC: 4)
  - [ ] Create lib/api/error-interceptor.ts:
    ```typescript
    import axios, { AxiosError } from 'axios';

    const MAX_RETRIES = 3;
    const RETRY_DELAY = 1000;

    axios.interceptors.response.use(
      (response) => response,
      async (error: AxiosError) => {
        const config = error.config;

        // Retry logic for 5xx errors and network errors
        if (shouldRetry(error) && config && config.retryCount < MAX_RETRIES) {
          config.retryCount = (config.retryCount || 0) + 1;
          await delay(RETRY_DELAY * config.retryCount);
          return axios(config);
        }

        // Handle specific error types
        if (error.response?.status === 401) {
          // Redirect to login or refresh token
          handleUnauthorized();
        } else if (error.response?.status === 403) {
          // Show access denied message
          handleForbidden();
        } else if (error.response?.status === 404) {
          // Show not found message
          handleNotFound();
        }

        return Promise.reject(error);
      }
    );

    function shouldRetry(error: AxiosError): boolean {
      return (
        !error.response || // Network error
        error.response.status >= 500 || // Server error
        error.code === 'ECONNABORTED' // Timeout
      );
    }
    ```
  - [ ] Configure retry logic for transient failures
  - [ ] Implement exponential backoff
  - [ ] Max 3 retries for 5xx errors
  - [ ] Don't retry 4xx errors (client errors)
  - [ ] Handle 401: redirect to login or refresh token
  - [ ] Handle 403: show access denied message
  - [ ] Handle 404: show not found message
  - [ ] Include correlation ID in requests if available

- [ ] Create error response types (AC: 4, 5)
  - [ ] Create types/api.ts:
    ```typescript
    interface ApiErrorResponse {
      timestamp: string;
      status: number;
      error: string;
      message: string;
      path: string;
      correlationId: string;
      fieldErrors?: FieldError[];
    }

    interface FieldError {
      field: string;
      message: string;
      rejectedValue: any;
    }

    class ApiError extends Error {
      constructor(
        public response: ApiErrorResponse,
        public correlationId: string
      ) {
        super(response.message);
        this.name = 'ApiError';
      }

      isValidationError(): boolean {
        return this.response.status === 400 && !!this.response.fieldErrors;
      }

      isNotFoundError(): boolean {
        return this.response.status === 404;
      }

      isUnauthorizedError(): boolean {
        return this.response.status === 401;
      }

      isForbiddenError(): boolean {
        return this.response.status === 403;
      }

      isServerError(): boolean {
        return this.response.status >= 500;
      }
    }
    ```
  - [ ] Parse error responses from API
  - [ ] Extract correlation ID for support
  - [ ] Extract field errors for form validation
  - [ ] Provide helper methods to check error types

- [ ] Implement user-friendly error messages (AC: 5)
  - [ ] Create lib/utils/error-messages.ts:
    ```typescript
    export function getErrorMessage(error: ApiError): string {
      if (error.isValidationError()) {
        return formatValidationErrors(error.response.fieldErrors);
      }

      const statusMessages: Record<number, string> = {
        400: 'There was a problem with your request. Please check your input and try again.',
        401: 'You need to log in to access this resource.',
        403: 'You do not have permission to perform this action.',
        404: 'The requested resource was not found.',
        409: 'This action conflicts with existing data. Please refresh and try again.',
        500: 'An unexpected error occurred. Please try again later.',
        503: 'The service is temporarily unavailable. Please try again later.',
      };

      return statusMessages[error.response.status] || error.response.message;
    }

    function formatValidationErrors(fieldErrors: FieldError[]): string {
      if (!fieldErrors || fieldErrors.length === 0) return '';
      return fieldErrors.map(e => `${e.field}: ${e.message}`).join(', ');
    }
    ```
  - [ ] Map technical errors to user-friendly messages
  - [ ] Provide actionable guidance ("Please try again", "Contact support")
  - [ ] Format validation errors as readable list
  - [ ] Include support contact for server errors
  - [ ] Don't expose technical details to users
  - [ ] Consistent tone and language

- [ ] Create error notification component (AC: 5)
  - [ ] Create components/ui/error-notification.tsx:
    ```typescript
    interface ErrorNotificationProps {
      error: ApiError;
      onClose: () => void;
    }

    export function ErrorNotification({ error, onClose }: ErrorNotificationProps) {
      const message = getErrorMessage(error);

      return (
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>Error</AlertTitle>
          <AlertDescription>
            {message}
            {error.correlationId && (
              <p className="text-xs mt-2">
                Reference ID: {error.correlationId}
              </p>
            )}
          </AlertDescription>
          <Button variant="ghost" size="sm" onClick={onClose}>
            Dismiss
          </Button>
        </Alert>
      );
    }
    ```
  - [ ] Use Shadcn/ui Alert component
  - [ ] Display user-friendly error message
  - [ ] Show correlation ID for support reference
  - [ ] Dismiss button to close notification
  - [ ] Auto-dismiss after 10 seconds (optional)
  - [ ] Stack multiple error notifications if needed
  - [ ] Different variants for warning vs error

- [ ] Implement toast notifications for errors (AC: 5)
  - [ ] Use Shadcn/ui Toast component
  - [ ] Create useErrorToast hook:
    ```typescript
    export function useErrorToast() {
      const { toast } = useToast();

      const showError = (error: ApiError) => {
        toast({
          variant: "destructive",
          title: "Error",
          description: getErrorMessage(error),
          duration: 5000,
        });
      };

      const showValidationError = (fieldErrors: FieldError[]) => {
        toast({
          variant: "destructive",
          title: "Validation Error",
          description: formatValidationErrors(fieldErrors),
          duration: 7000,
        });
      };

      return { showError, showValidationError };
    }
    ```
  - [ ] Show toast on API errors
  - [ ] Use destructive variant for errors
  - [ ] Auto-dismiss after 5-7 seconds
  - [ ] Stack multiple toasts
  - [ ] Include correlation ID in toast
  - [ ] Provide "Retry" action for retryable errors

- [ ] Add form validation error display (AC: 2, 5)
  - [ ] Update form components to display field errors
  - [ ] Parse fieldErrors from API response
  - [ ] Map field errors to form fields
  - [ ] Display inline error messages below fields
  - [ ] Use Shadcn/ui Form error display
  - [ ] Example in CustomerForm:
    ```typescript
    <FormField
      control={form.control}
      name="email"
      render={({ field }) => (
        <FormItem>
          <FormLabel>Email</FormLabel>
          <FormControl>
            <Input {...field} />
          </FormControl>
          <FormMessage /> {/* Shows validation error */}
        </FormItem>
      )}
    />
    ```
  - [ ] Highlight fields with errors (red border)
  - [ ] Show summary of errors at top of form
  - [ ] Focus first field with error

- [ ] Create error boundary components (AC: 7)
  - [ ] Create components/error-boundary.tsx:
    ```typescript
    import React, { Component, ErrorInfo, ReactNode } from 'react';

    interface Props {
      children: ReactNode;
      fallback?: ReactNode;
    }

    interface State {
      hasError: boolean;
      error?: Error;
    }

    export class ErrorBoundary extends Component<Props, State> {
      constructor(props: Props) {
        super(props);
        this.state = { hasError: false };
      }

      static getDerivedStateFromError(error: Error): State {
        return { hasError: true, error };
      }

      componentDidCatch(error: Error, errorInfo: ErrorInfo) {
        console.error('Error boundary caught error:', error, errorInfo);
        // Log to error tracking service (Sentry, LogRocket, etc.)
      }

      render() {
        if (this.state.hasError) {
          return this.props.fallback || (
            <div className="p-8 text-center">
              <h2 className="text-2xl font-bold mb-4">Something went wrong</h2>
              <p className="text-gray-600 mb-4">
                We're sorry, an unexpected error occurred. Please try refreshing the page.
              </p>
              <Button onClick={() => window.location.reload()}>
                Refresh Page
              </Button>
            </div>
          );
        }

        return this.props.children;
      }
    }
    ```
  - [ ] Wrap app in ErrorBoundary in app/layout.tsx
  - [ ] Wrap each major section in ErrorBoundary
  - [ ] Show user-friendly fallback UI
  - [ ] Log errors to console (and error tracking in production)
  - [ ] Provide refresh or retry option
  - [ ] Custom fallback for different sections
  - [ ] Reset error boundary on navigation

- [ ] Create custom error pages (AC: 8)
  - [ ] Create app/not-found.tsx (404 page):
    ```typescript
    export default function NotFound() {
      return (
        <div className="flex flex-col items-center justify-center min-h-screen">
          <h1 className="text-6xl font-bold">404</h1>
          <h2 className="text-2xl mb-4">Page Not Found</h2>
          <p className="text-gray-600 mb-8">
            The page you're looking for doesn't exist or has been moved.
          </p>
          <Link href="/">
            <Button>Go Home</Button>
          </Link>
        </div>
      );
    }
    ```
  - [ ] Create app/error.tsx (500 page):
    ```typescript
    'use client';

    export default function Error({
      error,
      reset,
    }: {
      error: Error & { digest?: string };
      reset: () => void;
    }) {
      return (
        <div className="flex flex-col items-center justify-center min-h-screen">
          <h1 className="text-6xl font-bold">500</h1>
          <h2 className="text-2xl mb-4">Server Error</h2>
          <p className="text-gray-600 mb-4">
            An unexpected error occurred. Please try again.
          </p>
          {error.digest && (
            <p className="text-sm text-gray-500 mb-8">
              Error ID: {error.digest}
            </p>
          )}
          <Button onClick={() => reset()}>Try Again</Button>
        </div>
      );
    }
    ```
  - [ ] Create 403 Forbidden page (if needed)
  - [ ] Use consistent design across error pages
  - [ ] Include navigation back to home
  - [ ] Include retry/refresh options
  - [ ] Show error ID/correlation ID for support
  - [ ] Match application styling
  - [ ] Test error pages in development

- [ ] Add error handling to API service methods (AC: 4, 5)
  - [ ] Wrap API calls in try-catch
  - [ ] Parse error responses
  - [ ] Convert to ApiError instances
  - [ ] Extract correlation ID
  - [ ] Example in lib/api/customers.ts:
    ```typescript
    export async function getCustomerById(id: string): Promise<CustomerResponseDTO> {
      try {
        const response = await axios.get(`/api/customers/${id}`);
        return response.data;
      } catch (error) {
        if (axios.isAxiosError(error) && error.response) {
          throw new ApiError(error.response.data, error.response.data.correlationId);
        }
        throw error;
      }
    }
    ```
  - [ ] Consistent error handling across all API methods
  - [ ] Don't swallow errors
  - [ ] Log errors to console in development
  - [ ] Provide helpful context in error messages

- [ ] Add error handling to Zustand stores (AC: 4, 5)
  - [ ] Update stores to handle API errors
  - [ ] Store error state in Zustand
  - [ ] Example in customer-store.ts:
    ```typescript
    interface CustomerStore {
      customers: Customer[];
      error: ApiError | null;
      loading: boolean;
      fetchCustomers: () => Promise<void>;
      clearError: () => void;
    }

    export const useCustomerStore = create<CustomerStore>((set) => ({
      customers: [],
      error: null,
      loading: false,

      fetchCustomers: async () => {
        set({ loading: true, error: null });
        try {
          const customers = await getCustomers();
          set({ customers, loading: false });
        } catch (error) {
          set({ error: error as ApiError, loading: false });
        }
      },

      clearError: () => set({ error: null }),
    }));
    ```
  - [ ] Provide clearError action
  - [ ] Display error from store in components
  - [ ] Auto-clear errors on successful operations
  - [ ] Use error toast when error occurs

- [ ] Create error handling documentation (AC: 1-8)
  - [ ] Document error response format
  - [ ] Document custom exception types
  - [ ] Document error codes and their meanings
  - [ ] Document correlation ID usage
  - [ ] Provide examples of error responses
  - [ ] Document retry logic in frontend
  - [ ] Document error boundary usage
  - [ ] Document how to add new error types
  - [ ] Add to backend/docs/error-handling.md

- [ ] Add error handling tests (AC: 1-8)
  - [ ] Test GlobalExceptionHandler:
    - Test validation error response format
    - Test domain exception handling
    - Test authentication error handling
    - Test generic exception handling
    - Verify correlation ID in response
  - [ ] Test custom exceptions:
    - Test EntityNotFoundException thrown and caught
    - Test BusinessRuleViolationException
    - Test InvalidStateTransitionException
    - Test ValidationException with field errors
  - [ ] Test error interceptor:
    - Test retry logic for 5xx errors
    - Test no retry for 4xx errors
    - Test exponential backoff
    - Test max retry limit
  - [ ] Test error boundary:
    - Test renders fallback on error
    - Test logs error to console
    - Test reset functionality
  - [ ] Test error pages:
    - Test 404 page renders
    - Test 500 page renders
    - Test navigation links work
  - [ ] Integration tests for error scenarios:
    - Test API returns proper error format
    - Test field errors for validation
    - Test error codes match expected values

- [ ] Configure error monitoring (AC: 6)
  - [ ] Add structured logging configuration
  - [ ] Configure log levels for different environments
  - [ ] Add correlation ID to all log statements
  - [ ] Log errors with full stack traces
  - [ ] Log request/response for debugging
  - [ ] Don't log sensitive data (passwords, tokens)
  - [ ] Configure log aggregation (optional for production)
  - [ ] Set up error alerting (optional for production)
  - [ ] Document error monitoring setup

- [ ] Add accessibility to error messages (AC: 5, 8)
  - [ ] Use ARIA live regions for dynamic error messages
  - [ ] Announce errors to screen readers
  - [ ] Example:
    ```typescript
    <div role="alert" aria-live="assertive">
      {error && <ErrorMessage error={error} />}
    </div>
    ```
  - [ ] Use semantic HTML for error messages
  - [ ] Ensure color contrast for error text (red)
  - [ ] Provide text alternatives for error icons
  - [ ] Focus management after error (focus first error field)
  - [ ] Keyboard accessible error dialogs
  - [ ] Test with screen reader

## Dev Notes

### Previous Story Insights

**Story 4.1 Completion:**
Story 4.1 will implement comprehensive integration testing:
- TestContainers for database testing
- End-to-end flow tests (Customer→Invoice→Payment)
- API integration tests for all endpoints
- Negative test cases for error conditions
- Coverage reporting with JaCoCo

This story (4.2) will ensure those error conditions are properly handled and tested.

**Epic 3 Error Handling:**
Stories 3.1-3.5 implemented basic error handling:
- Domain validation in entities
- Try-catch in API service methods
- Toast notifications for errors
- Form validation with React Hook Form

This story will standardize and expand error handling across the entire application.

**Epic 2 Error Patterns:**
Stories 2.1-2.5 used ad-hoc error handling:
- Throw exceptions from domain entities
- Catch in controllers and return error responses
- No standard error format
- Limited field-level validation

This story will create a consistent error handling framework.

**Epic 1 Authentication Errors:**
Story 1.2 implemented basic authentication error handling:
- 401 for invalid credentials
- JWT validation errors
- No correlation ID tracking

This story will enhance authentication error handling.

### Architecture Context

**Error Handling Requirements** [Source: PRD Epic 4 Story 4.2, architecture.md]:
- Global exception handler with standard error format
- Domain validation exceptions with field-level errors
- Custom exception types for business rules
- Client-side error interceptor with retry logic
- User-friendly error messages
- Logging with correlation IDs
- Error boundary components in React
- Custom error pages (404, 403, 500)

**Error Response Format** [Derived from best practices]:
```json
{
  "timestamp": "2024-11-08T14:30:00.000Z",
  "status": 400,
  "error": "Bad Request",
  "message": "Validation failed",
  "path": "/api/invoices",
  "correlationId": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "fieldErrors": [
    {
      "field": "lineItems",
      "message": "At least one line item is required",
      "rejectedValue": []
    }
  ]
}
```

**Logging Strategy** [Source: architecture.md#Tech Stack]:
- SLF4J/Logback for backend logging
- Console logging for development
- Structured JSON logging for production
- Correlation ID in all log statements
- Different log levels: DEBUG, INFO, WARN, ERROR
- Log SQL statements in development
- Don't log sensitive data

### Data Models

**ApiErrorResponse** [New]:
```java
public record ApiErrorResponse(
    String timestamp,
    int status,
    String error,
    String message,
    String path,
    String correlationId,
    List<FieldError> fieldErrors
) {
    public static record FieldError(
        String field,
        String message,
        Object rejectedValue
    ) {}

    public static ApiErrorResponse of(HttpStatus status, String message, String path, String correlationId) {
        return new ApiErrorResponse(
            ZonedDateTime.now().toString(),
            status.value(),
            status.getReasonPhrase(),
            message,
            path,
            correlationId,
            null
        );
    }

    public static ApiErrorResponse ofValidation(String path, String correlationId, List<FieldError> fieldErrors) {
        return new ApiErrorResponse(
            ZonedDateTime.now().toString(),
            HttpStatus.BAD_REQUEST.value(),
            "Bad Request",
            "Validation failed",
            path,
            correlationId,
            fieldErrors
        );
    }
}
```

**Custom Exception Hierarchy** [New]:
```
RuntimeException
└── DomainException (base for all domain exceptions)
    ├── EntityNotFoundException
    ├── BusinessRuleViolationException
    ├── InvalidStateTransitionException
    ├── InsufficientBalanceException
    ├── DuplicateEntityException
    └── ValidationException
```

### API Specifications

**Error Response Examples:**

**Validation Error (400):**
```json
{
  "timestamp": "2024-11-08T14:30:00.000Z",
  "status": 400,
  "error": "Bad Request",
  "message": "Validation failed",
  "path": "/api/customers",
  "correlationId": "a1b2c3d4",
  "fieldErrors": [
    {
      "field": "email",
      "message": "Email must be valid",
      "rejectedValue": "invalid-email"
    }
  ]
}
```

**Not Found (404):**
```json
{
  "timestamp": "2024-11-08T14:30:00.000Z",
  "status": 404,
  "error": "Not Found",
  "message": "Customer not found with ID: 12345",
  "path": "/api/customers/12345",
  "correlationId": "b2c3d4e5",
  "fieldErrors": null
}
```

**Business Rule Violation (400):**
```json
{
  "timestamp": "2024-11-08T14:30:00.000Z",
  "status": 400,
  "error": "Bad Request",
  "message": "Cannot send invoice without line items",
  "path": "/api/invoices/123/send",
  "correlationId": "c3d4e5f6",
  "fieldErrors": null
}
```

**Unauthorized (401):**
```json
{
  "timestamp": "2024-11-08T14:30:00.000Z",
  "status": 401,
  "error": "Unauthorized",
  "message": "Invalid or expired token",
  "path": "/api/customers",
  "correlationId": "d4e5f6g7",
  "fieldErrors": null
}
```

**Server Error (500):**
```json
{
  "timestamp": "2024-11-08T14:30:00.000Z",
  "status": 500,
  "error": "Internal Server Error",
  "message": "An unexpected error occurred. Please try again later.",
  "path": "/api/invoices",
  "correlationId": "e5f6g7h8",
  "fieldErrors": null
}
```

### Component Specifications

**GlobalExceptionHandler** [Source: architecture.md#Components]:
- Location: backend/src/main/java/com/invoiceme/common/exceptions/GlobalExceptionHandler.java
- Annotated with @RestControllerAdvice
- Methods:
  - handleValidationException(MethodArgumentNotValidException)
  - handleConstraintViolation(ConstraintViolationException)
  - handleEntityNotFound(EntityNotFoundException)
  - handleBusinessRuleViolation(BusinessRuleViolationException)
  - handleInvalidStateTransition(InvalidStateTransitionException)
  - handleInsufficientBalance(InsufficientBalanceException)
  - handleDuplicateEntity(DuplicateEntityException)
  - handleAuthentication(AuthenticationException)
  - handleAccessDenied(AccessDeniedException)
  - handleGenericException(Exception)
- All methods return ApiErrorResponse with correlation ID

**CorrelationIdFilter** [New]:
- Location: backend/src/main/java/com/invoiceme/common/filters/CorrelationIdFilter.java
- Extends OncePerRequestFilter
- Generates or extracts correlation ID from header
- Stores in MDC for logging
- Returns in response header

**ErrorBoundary** [New]:
- Location: components/error-boundary.tsx
- React error boundary component
- Catches React rendering errors
- Shows fallback UI
- Logs errors to console
- Provides reset/refresh option

**ErrorInterceptor** [New]:
- Location: lib/api/error-interceptor.ts
- Axios response interceptor
- Handles retry logic for 5xx errors
- Handles authentication errors (401)
- Handles authorization errors (403)
- Extracts correlation ID from responses

### File Locations

**Backend Files** [Source: architecture.md#Unified Project Structure]:
```
backend/src/main/java/com/invoiceme/
├── common/
│   ├── dto/
│   │   └── ApiErrorResponse.java                     # Standard error response (NEW)
│   ├── exceptions/
│   │   ├── GlobalExceptionHandler.java               # Global exception handler (NEW)
│   │   ├── DomainException.java                      # Base domain exception (NEW)
│   │   ├── EntityNotFoundException.java              # Entity not found (NEW)
│   │   ├── BusinessRuleViolationException.java       # Business rule violation (NEW)
│   │   ├── InvalidStateTransitionException.java      # Invalid state transition (NEW)
│   │   ├── InsufficientBalanceException.java         # Payment exceeds balance (NEW)
│   │   ├── DuplicateEntityException.java             # Uniqueness violation (NEW)
│   │   └── ValidationException.java                  # Validation errors (NEW)
│   └── filters/
│       ├── CorrelationIdFilter.java                  # Correlation ID filter (NEW)
│       └── RequestResponseLoggingFilter.java         # Request/response logging (NEW)
└── config/
    └── SecurityConfig.java                           # Register filters (MODIFY)

backend/src/main/resources/
├── logback-spring.xml                                # Logback configuration (NEW)
└── application.yml                                   # Logging configuration (MODIFY)

backend/docs/
└── error-handling.md                                 # Error handling documentation (NEW)
```

**Frontend Files** [Source: architecture.md#Unified Project Structure]:
```
lib/api/
├── error-interceptor.ts                              # Axios error interceptor (NEW)
└── client.ts                                         # Axios setup (MODIFY to add interceptor)

types/
└── api.ts                                            # ApiErrorResponse, ApiError types (NEW)

lib/utils/
└── error-messages.ts                                 # User-friendly error messages (NEW)

components/
├── error-boundary.tsx                                # Error boundary component (NEW)
└── ui/
    └── error-notification.tsx                        # Error notification component (NEW)

app/
├── not-found.tsx                                     # 404 page (NEW)
├── error.tsx                                         # 500 page (NEW)
└── layout.tsx                                        # Wrap in ErrorBoundary (MODIFY)

hooks/
└── use-error-toast.ts                                # Error toast hook (NEW)
```

### Testing Requirements

**Backend Tests** [Source: PRD Epic 4 Story 4.2]:
- GlobalExceptionHandler tests:
  - Test each exception type handled
  - Verify error response format
  - Verify correlation ID included
  - Verify HTTP status codes
- Custom exception tests:
  - Test exception creation
  - Test exception details
  - Test error codes
- Integration tests for error scenarios:
  - Test validation errors return 400 with field errors
  - Test entity not found returns 404
  - Test business rule violations return 400
  - Test authentication errors return 401
  - Test server errors return 500
- Logging tests:
  - Test correlation ID in MDC
  - Test request/response logging
  - Test error logging with stack traces

**Frontend Tests** [Source: PRD Epic 4 Story 4.2]:
- Error interceptor tests:
  - Test retry logic for 5xx errors
  - Test no retry for 4xx errors
  - Test max retry limit
  - Test exponential backoff
  - Test 401 redirect to login
- Error boundary tests:
  - Test catches errors
  - Test renders fallback UI
  - Test reset functionality
- Error notification tests:
  - Test displays error message
  - Test shows correlation ID
  - Test dismiss functionality
- Error page tests:
  - Test 404 page renders
  - Test 500 page renders
  - Test navigation works
  - Test retry button works

### Technical Constraints

**Dependencies** [Source: architecture.md#Tech Stack]:
- Spring Boot 3.2.x (includes Spring Web exception handling)
- SLF4J/Logback (logging)
- Axios (HTTP client with interceptors)
- React 18 (error boundaries)
- Shadcn/ui (Alert, Toast components)

**Spring Boot Validation** [Source: architecture.md#Tech Stack]:
- javax.validation annotations (@NotNull, @NotBlank, @Email, etc.)
- @Valid annotation in controllers to trigger validation
- MethodArgumentNotValidException thrown for validation errors

**Logging Configuration** [Source: architecture.md]:
- Logback for backend logging
- MDC for correlation ID
- Different log levels for dev vs production
- Structured JSON logging for production
- Log rotation and retention

**Error Response Requirements** [Source: PRD NFR]:
- Consistent format across all errors
- Include correlation ID for tracing
- Don't expose stack traces in production
- User-friendly messages (not technical jargon)
- Field-level errors for validation
- Appropriate HTTP status codes

### Coding Standards

**Critical Error Handling Rules** [Source: architecture.md#Coding Standards]:
- Always use custom domain exceptions (not generic RuntimeException)
- Include correlation ID in all error responses
- Log all errors with appropriate level
- Don't expose internal details to users
- Provide actionable error messages
- Handle all exception types in GlobalExceptionHandler
- Use @RestControllerAdvice for centralized exception handling
- Return ApiErrorResponse for all errors

**Exception Naming Convention:**
- Format: `{Purpose}Exception`
- Examples:
  - EntityNotFoundException
  - BusinessRuleViolationException
  - InvalidStateTransitionException
  - ValidationException
- All extend DomainException base class
- Include error code and details

**Error Message Guidelines:**
- User-facing messages should be clear and actionable
- Technical details in logs only
- Consistent tone and language
- Examples:
  - Good: "Payment amount cannot exceed invoice balance"
  - Bad: "InsufficientBalanceException: amount > balance"
- Include field name for validation errors
- Include entity type and ID for not found errors

**Correlation ID Usage:**
- Generate UUID if not provided in request header
- Store in MDC for logging
- Include in all log statements
- Return in response header (X-Correlation-ID)
- Include in error responses
- Display to user for support reference

## Testing
- Backend unit tests for GlobalExceptionHandler
- Backend unit tests for custom exceptions
- Backend integration tests for error scenarios
- Frontend tests for error interceptor
- Frontend tests for error boundary
- Frontend tests for error notifications
- Frontend tests for error pages
- E2E tests for error flows (validation, not found, server error)
- Accessibility tests for error messages

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-11-08 | v1.0 | Initial story creation from PRD Epic 4 Story 4.2 | Claude (Story Agent) |

## Dev Agent Record

### Agent Model Used
Not yet implemented

### Debug Log References
None yet - will be populated during implementation

### Completion Notes List
None yet - will be populated during implementation

### File List
None yet - will be populated during implementation

## QA Results
Not yet reviewed
