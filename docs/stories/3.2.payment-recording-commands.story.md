# Story 3.2: Payment Recording Commands

## Status
Draft

## Story
**As a** developer,
**I want** to implement payment recording with invoice state updates,
**so that** payments properly affect invoice status and balance.

## Acceptance Criteria
1. RecordPaymentCommand creates payment and updates invoice balance
2. Payment application triggers invoice status change to Paid when balance=0
3. Partial payment support with remaining balance calculation
4. Command validation prevents payment on Draft invoices
5. REST endpoint: POST /api/invoices/{id}/payments
6. Transactional consistency between payment creation and invoice update
7. Domain event: PaymentRecorded with invoice and payment details
8. Idempotency handling to prevent duplicate payment recording

## Tasks / Subtasks
- [ ] Create RecordPaymentCommand (AC: 1, 4)
  - [ ] Create RecordPaymentCommand.java in features/payment/commands/
  - [ ] Add record fields: UUID invoiceId, LocalDate paymentDate, BigDecimal amount
  - [ ] Add fields: PaymentMethod paymentMethod, String reference, String notes
  - [ ] Add validation annotations: @NotNull on invoiceId, paymentDate, amount, paymentMethod
  - [ ] Add @Positive annotation on amount
  - [ ] Add @PastOrPresent annotation on paymentDate (cannot be in future)
  - [ ] Ensure command is immutable (Java record)
  - [ ] Add JavaDoc explaining command purpose and validation rules

- [ ] Create RecordPaymentCommandHandler (AC: 1, 2, 3, 4, 6)
  - [ ] Create RecordPaymentCommandHandler.java in features/payment/commands/
  - [ ] Annotate with @Service
  - [ ] Inject dependencies: PaymentRepository, InvoiceRepository, PaymentService
  - [ ] Create method: handle(RecordPaymentCommand command, String userId)
  - [ ] Annotate handle method with @Transactional (ensures atomicity)
  - [ ] Step 1: Fetch invoice by ID, throw NotFoundException if not found
  - [ ] Step 2: Validate invoice status (must be Sent, not Draft or Paid)
  - [ ] Step 3: Create Payment entity using Payment.createPayment() factory
  - [ ] Step 4: Validate payment against invoice using PaymentService.validatePaymentAgainstInvoice()
  - [ ] Step 5: Calculate new balance using PaymentService.calculateNewBalance()
  - [ ] Step 6: Update invoice balance (invoice.setBalance(newBalance))
  - [ ] Step 7: Check if invoice should be marked as Paid using PaymentService.shouldMarkInvoiceAsPaid()
  - [ ] Step 8: If balance is zero, update invoice status to Paid (invoice.setStatus(InvoiceStatus.PAID))
  - [ ] Step 9: Save payment to database (paymentRepository.save(payment))
  - [ ] Step 10: Save updated invoice (invoiceRepository.save(invoice))
  - [ ] Step 11: Publish PaymentRecorded domain event (if event publishing is implemented)
  - [ ] Step 12: Return PaymentResponseDTO with updated invoice information
  - [ ] Add error handling for DomainException (payment validation failures)
  - [ ] Add logging for payment recording events (info level)
  - [ ] Ensure @Transactional rollback on any exception

- [ ] Enhance Invoice entity for payment support (AC: 2, 3)
  - [ ] Add method to Invoice.java: applyPayment(BigDecimal paymentAmount)
  - [ ] Update balance field: this.balance = this.balance.subtract(paymentAmount)
  - [ ] Add validation: ensure new balance doesn't go negative
  - [ ] Add method: markAsPaid() to transition status to PAID
  - [ ] Add validation: only allow Sent -> Paid transition
  - [ ] Add method: canAcceptPayment() returns true if status is Sent
  - [ ] Update Invoice entity tests to cover new payment methods
  - [ ] Ensure payment application maintains domain invariants

- [ ] Create PaymentRecorded domain event (AC: 7)
  - [ ] Create PaymentRecorded.java in features/payment/domain/events/
  - [ ] Add record fields: UUID paymentId, UUID invoiceId, BigDecimal amount
  - [ ] Add fields: LocalDate paymentDate, BigDecimal newBalance, InvoiceStatus newStatus
  - [ ] Add field: LocalDateTime occurredAt
  - [ ] Implement as immutable record
  - [ ] Add factory method: PaymentRecorded.of(Payment payment, Invoice invoice)
  - [ ] Add JavaDoc explaining event purpose and when it's published
  - [ ] Note: Event publishing infrastructure to be used if available, otherwise log event

- [ ] Create PaymentCommandController (AC: 5)
  - [ ] Create PaymentCommandController.java in features/payment/api/
  - [ ] Annotate with @RestController and @RequestMapping("/api/invoices")
  - [ ] Inject RecordPaymentCommandHandler dependency
  - [ ] Inject SecurityContext for getting current user
  - [ ] Create endpoint: POST /api/invoices/{id}/payments
  - [ ] Path variable: @PathVariable UUID id (invoice ID)
  - [ ] Request body: @RequestBody @Valid RecordPaymentDTO dto
  - [ ] Get current user from SecurityContext: String userId = SecurityContextHolder.getContext().getAuthentication().getName()
  - [ ] Create command from DTO: new RecordPaymentCommand(id, dto.paymentDate(), dto.amount(), ...)
  - [ ] Call handler: PaymentResponseDTO response = handler.handle(command, userId)
  - [ ] Return ResponseEntity.status(201).body(response)
  - [ ] Add @PreAuthorize annotation for authentication requirement
  - [ ] Add Swagger/OpenAPI annotations: @Operation, @ApiResponse, @Parameter
  - [ ] Document expected responses: 201 Created, 400 Bad Request, 404 Not Found, 401 Unauthorized

- [ ] Implement idempotency handling (AC: 8)
  - [ ] Add idempotency key support to RecordPaymentCommand
  - [ ] Add optional field: String idempotencyKey in RecordPaymentDTO
  - [ ] Create IdempotencyRecord entity in common/idempotency/
  - [ ] Fields: String key, String result, LocalDateTime createdAt, LocalDateTime expiresAt
  - [ ] Create IdempotencyRepository interface
  - [ ] In handler, check if idempotency key exists before processing
  - [ ] If key exists and not expired, return cached response (prevent duplicate)
  - [ ] If key doesn't exist, process command and store result with key
  - [ ] Set expiration time (e.g., 24 hours) for idempotency records
  - [ ] Add index on idempotency key for fast lookup
  - [ ] Test idempotency: same request twice should only create one payment
  - [ ] Note: Idempotency key is optional; if not provided, duplicate detection is not enforced

- [ ] Add comprehensive validation (AC: 4)
  - [ ] Controller level: @Valid annotation triggers DTO validation
  - [ ] DTO level: @NotNull, @Positive, @PastOrPresent annotations
  - [ ] Domain level: Payment.createPayment() validates business rules
  - [ ] Service level: PaymentService.validatePaymentAgainstInvoice() checks cross-aggregate rules
  - [ ] Validation error responses: 400 Bad Request with field-level errors
  - [ ] Create GlobalExceptionHandler if not exists (from Story 4.2 - may already exist)
  - [ ] Add handler for MethodArgumentNotValidException (validation errors)
  - [ ] Add handler for DomainException (business rule violations)
  - [ ] Return standard error format: ApiErrorResponse with message, field errors, timestamp
  - [ ] Test validation at all layers

- [ ] Create integration tests for RecordPaymentCommand (AC: 1-8)
  - [ ] Create RecordPaymentCommandHandlerTest.java in src/test/java/features/payment/commands/
  - [ ] Use @SpringBootTest for full integration testing
  - [ ] Use @Transactional for test isolation (rollback after each test)
  - [ ] Use TestContainers with PostgreSQL for realistic database
  - [ ] Test successful payment recording updates invoice balance
  - [ ] Test successful payment recording with balance=0 marks invoice as Paid
  - [ ] Test partial payment leaves invoice in Sent status with reduced balance
  - [ ] Test payment recording on Draft invoice throws exception
  - [ ] Test payment recording on Paid invoice throws exception
  - [ ] Test payment amount exceeding balance throws exception
  - [ ] Test negative payment amount throws validation exception
  - [ ] Test future payment date throws validation exception
  - [ ] Test missing required fields throws validation exception
  - [ ] Test payment recording with idempotency key prevents duplicates
  - [ ] Test transaction rollback on payment validation failure
  - [ ] Verify PaymentRecorded event is published (if event system exists)
  - [ ] Use test data builders for setup (InvoiceTestBuilder, PaymentTestBuilder)
  - [ ] Achieve >90% code coverage on command handler

- [ ] Create API integration tests (AC: 5)
  - [ ] Create PaymentCommandControllerTest.java in src/test/java/features/payment/api/
  - [ ] Use @WebMvcTest(PaymentCommandController.class) or @SpringBootTest
  - [ ] Use MockMvc for HTTP request simulation
  - [ ] Test POST /api/invoices/{id}/payments with valid payload returns 201 Created
  - [ ] Test response includes PaymentResponseDTO with all fields
  - [ ] Test POST with invalid invoice ID returns 404 Not Found
  - [ ] Test POST with invalid payload returns 400 Bad Request
  - [ ] Test POST without authentication returns 401 Unauthorized
  - [ ] Test POST with payment exceeding balance returns 400 Bad Request
  - [ ] Test POST to draft invoice returns 400 Bad Request
  - [ ] Test error response format matches ApiErrorResponse structure
  - [ ] Use JSON path assertions to verify response structure
  - [ ] Mock authentication with @WithMockUser annotation
  - [ ] Verify handler is called with correct command parameters
  - [ ] Test idempotency: same idempotency key returns 200 OK with cached response

- [ ] Add API documentation (AC: 5)
  - [ ] Add OpenAPI annotations to PaymentCommandController
  - [ ] @Operation summary: "Record payment against invoice"
  - [ ] @Operation description: "Creates a payment record and updates invoice balance. If balance reaches zero, marks invoice as Paid."
  - [ ] @ApiResponse 201: "Payment recorded successfully"
  - [ ] @ApiResponse 400: "Invalid request or business rule violation"
  - [ ] @ApiResponse 404: "Invoice not found"
  - [ ] @ApiResponse 401: "Unauthorized - authentication required"
  - [ ] @Parameter for path variable: id (Invoice ID)
  - [ ] @RequestBody for RecordPaymentDTO with example
  - [ ] Add example JSON for request body
  - [ ] Add example JSON for success response
  - [ ] Update Swagger UI with payment endpoints
  - [ ] Test Swagger documentation renders correctly

- [ ] Update Invoice command handlers for payment integration (AC: 2)
  - [ ] Update SendInvoiceCommand to set initial balance = totalAmount
  - [ ] Ensure invoice.balance is initialized when status changes to Sent
  - [ ] Add validation: cannot send invoice if totalAmount is zero
  - [ ] Update invoice state transition tests to verify balance initialization
  - [ ] Ensure UpdateInvoiceCommand prevents modification of Sent invoices
  - [ ] Test that Sent invoices cannot be edited (only Draft invoices)

- [ ] Add logging and monitoring (AC: 1, 6)
  - [ ] Add SLF4J Logger to RecordPaymentCommandHandler
  - [ ] Log info: "Recording payment for invoice {invoiceId}, amount {amount}"
  - [ ] Log info: "Payment recorded successfully: {paymentId}, new balance: {newBalance}"
  - [ ] Log info: "Invoice {invoiceId} marked as Paid due to zero balance"
  - [ ] Log warning: "Payment validation failed: {reason}"
  - [ ] Log error: "Payment recording failed: {exception}" (on unexpected errors)
  - [ ] Add correlation ID to logs (MDC - Mapped Diagnostic Context)
  - [ ] Ensure sensitive data (payment details) not logged in production
  - [ ] Add metrics for payment recording success/failure rates (if monitoring exists)

- [ ] Create comprehensive error handling (AC: 4, 5)
  - [ ] Create specific exceptions for payment scenarios
  - [ ] InvoiceNotSentException: thrown when payment applied to non-Sent invoice
  - [ ] PaymentExceedsBalanceException: thrown when payment > invoice balance
  - [ ] InvalidPaymentException: already created in Story 3.1 for domain validation
  - [ ] Update GlobalExceptionHandler to handle payment-specific exceptions
  - [ ] Map InvoiceNotSentException to 400 Bad Request
  - [ ] Map PaymentExceedsBalanceException to 400 Bad Request
  - [ ] Map InvalidPaymentException to 400 Bad Request
  - [ ] Map EntityNotFoundException to 404 Not Found
  - [ ] Return user-friendly error messages explaining what went wrong
  - [ ] Include field-level errors for validation failures
  - [ ] Test error responses match expected format

- [ ] Implement transactional consistency (AC: 6)
  - [ ] Ensure @Transactional annotation on handler.handle() method
  - [ ] Verify transaction isolation level is READ_COMMITTED (Spring default)
  - [ ] Test transaction rollback on validation failure (no payment or invoice update)
  - [ ] Test transaction rollback on database constraint violation
  - [ ] Test concurrent payment attempts with optimistic locking (if implemented)
  - [ ] Add @Version field to Invoice entity for optimistic locking (if not exists)
  - [ ] Handle OptimisticLockException and return 409 Conflict
  - [ ] Test race condition: two payments applied simultaneously
  - [ ] Verify payment + invoice update happen atomically (both or neither)

- [ ] Add payment recording to API service layer (Frontend preparation)
  - [ ] This is backend-only, but verify API contract matches frontend expectations
  - [ ] RecordPaymentDTO structure matches TypeScript RecordPaymentDTO interface
  - [ ] PaymentResponseDTO structure matches TypeScript PaymentResponseDTO interface
  - [ ] Error response format is consistent with other endpoints
  - [ ] Update architecture.md with API endpoint documentation
  - [ ] Update PRD API specification section if needed

- [ ] Performance optimization (AC: 1, 6)
  - [ ] Ensure payment recording completes in <200ms (PRD NFR1)
  - [ ] Add database index on payments.invoice_id (already in Story 3.1)
  - [ ] Optimize query to fetch invoice by ID (use findById for cache)
  - [ ] Avoid N+1 queries when loading invoice with related entities
  - [ ] Test payment recording performance with realistic data volume
  - [ ] Profile database queries during payment recording
  - [ ] Ensure transaction is as short as possible (no external calls within transaction)

## Dev Notes

### Previous Story Insights

**Story 3.1 Completion:**
Story 3.1 implemented the Payment domain model:
- Payment entity with validation logic
- PaymentMethod enum (CreditCard, BankTransfer, Check, Cash)
- Payment.createPayment() factory method with business rule validation
- PaymentRepository interface with query methods
- PaymentService for payment-invoice reconciliation logic
- Database migration V3__create_payments_table.sql
- Comprehensive unit tests for Payment entity and PaymentService

**Story 2.2 Completion:**
Story 2.2 implemented Invoice command operations:
- CreateInvoiceCommand, UpdateInvoiceCommand, SendInvoiceCommand
- InvoiceCommandHandler with state transition logic
- Invoice lifecycle: Draft → Sent → Paid
- Optimistic locking with @Version field
- Validation preventing modification of Sent/Paid invoices
- Integration tests for all commands

**Epic 1 Patterns:**
Epic 1 established command handling patterns:
- Command DTOs as immutable records
- CommandHandler services with @Transactional
- Controller → Handler → Domain pattern
- REST controllers with OpenAPI documentation
- GlobalExceptionHandler for consistent error responses
- Integration tests with TestContainers

### Data Models

**RecordPaymentCommand** [Derived from PRD Epic 3 Story 3.2 AC 1]:
```java
package com.invoiceme.features.payment.commands;

import com.invoiceme.features.payment.domain.PaymentMethod;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Positive;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.UUID;

/**
 * Command to record a payment against an invoice.
 * Immutable command following CQRS pattern.
 */
public record RecordPaymentCommand(
    @NotNull UUID invoiceId,
    @NotNull @PastOrPresent LocalDate paymentDate,
    @NotNull @Positive BigDecimal amount,
    @NotNull PaymentMethod paymentMethod,
    String reference,
    String notes,
    String idempotencyKey  // Optional - for preventing duplicate payments
) {}
```

**RecordPaymentDTO** [Source: architecture.md#Data Models]:
```java
package com.invoiceme.features.payment.commands;

import com.invoiceme.features.payment.domain.PaymentMethod;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Positive;
import java.math.BigDecimal;
import java.time.LocalDate;

/**
 * DTO for recording payment via REST API.
 * Maps to RecordPaymentCommand in controller.
 */
public record RecordPaymentDTO(
    @NotNull LocalDate paymentDate,
    @NotNull @Positive BigDecimal amount,
    @NotNull PaymentMethod paymentMethod,
    String reference,
    String notes,
    String idempotencyKey
) {}
```

**PaymentRecorded Event** [Derived from PRD Epic 3 Story 3.2 AC 7]:
```java
package com.invoiceme.features.payment.domain.events;

import com.invoiceme.features.invoice.domain.InvoiceStatus;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Domain event published when a payment is successfully recorded.
 * Can be used for audit logging, notification triggers, or event sourcing.
 */
public record PaymentRecorded(
    UUID paymentId,
    UUID invoiceId,
    BigDecimal amount,
    LocalDate paymentDate,
    BigDecimal newBalance,
    InvoiceStatus newStatus,
    LocalDateTime occurredAt
) {
    public static PaymentRecorded of(Payment payment, Invoice invoice) {
        return new PaymentRecorded(
            payment.getId(),
            payment.getInvoiceId(),
            payment.getAmount(),
            payment.getPaymentDate(),
            invoice.getBalance(),
            invoice.getStatus(),
            LocalDateTime.now()
        );
    }
}
```

**Updated Invoice Entity Methods** [Derived from PRD Epic 3 Story 3.2 AC 2, 3]:
```java
// Add to Invoice.java
public void applyPayment(BigDecimal paymentAmount) {
    if (!canAcceptPayment()) {
        throw new DomainException("Invoice must be in Sent status to accept payments");
    }
    if (paymentAmount.compareTo(balance) > 0) {
        throw new DomainException("Payment amount cannot exceed invoice balance");
    }
    this.balance = this.balance.subtract(paymentAmount);
    this.updatedAt = LocalDateTime.now();
}

public boolean canAcceptPayment() {
    return this.status == InvoiceStatus.SENT;
}

public void markAsPaid() {
    if (this.status != InvoiceStatus.SENT) {
        throw new DomainException("Can only mark Sent invoices as Paid");
    }
    if (this.balance.compareTo(BigDecimal.ZERO) > 0.01) {
        throw new DomainException("Cannot mark invoice as Paid with non-zero balance");
    }
    this.status = InvoiceStatus.PAID;
    this.updatedAt = LocalDateTime.now();
}
```

### API Specifications

**POST /api/invoices/{id}/payments** [Source: architecture.md#API Specification, PRD Epic 3 Story 3.2 AC 5]:

**Request:**
```
POST /api/invoices/{id}/payments
Content-Type: application/json
Authorization: Bearer {jwt_token}

{
  "paymentDate": "2024-11-08",
  "amount": 250.00,
  "paymentMethod": "CreditCard",
  "reference": "VISA-****-1234",
  "notes": "Partial payment received",
  "idempotencyKey": "payment-20241108-invoice-123-001"  // Optional
}
```

**Response (201 Created):**
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "invoiceId": "660e8400-e29b-41d4-a716-446655440000",
  "invoiceNumber": "INV-2024-0123",
  "customerName": "Acme Corporation",
  "paymentDate": "2024-11-08",
  "amount": 250.00,
  "paymentMethod": "CreditCard",
  "reference": "VISA-****-1234",
  "notes": "Partial payment received",
  "remainingBalance": 250.00,
  "createdAt": "2024-11-08T14:30:00Z",
  "createdBy": "user@example.com"
}
```

**Error Responses:**

**400 Bad Request - Validation Error:**
```json
{
  "timestamp": "2024-11-08T14:30:00Z",
  "status": 400,
  "error": "Bad Request",
  "message": "Validation failed",
  "errors": [
    {
      "field": "amount",
      "message": "Payment amount must be positive"
    },
    {
      "field": "paymentDate",
      "message": "Payment date cannot be in the future"
    }
  ]
}
```

**400 Bad Request - Business Rule Violation:**
```json
{
  "timestamp": "2024-11-08T14:30:00Z",
  "status": 400,
  "error": "Bad Request",
  "message": "Cannot apply payment to draft invoice. Invoice must be sent before accepting payments.",
  "invoiceId": "660e8400-e29b-41d4-a716-446655440000",
  "invoiceStatus": "Draft"
}
```

**404 Not Found:**
```json
{
  "timestamp": "2024-11-08T14:30:00Z",
  "status": 404,
  "error": "Not Found",
  "message": "Invoice not found with id: 660e8400-e29b-41d4-a716-446655440000"
}
```

**409 Conflict - Duplicate Payment (Idempotency):**
```json
{
  "timestamp": "2024-11-08T14:30:00Z",
  "status": 200,
  "message": "Payment already recorded (idempotent response)",
  "payment": { /* existing PaymentResponseDTO */ }
}
```

### Component Specifications

**RecordPaymentCommandHandler** [Derived from PRD Epic 3 Story 3.2 AC 1, 2, 3, 4, 6]:
- Location: backend/src/main/java/com/invoiceme/features/payment/commands/RecordPaymentCommandHandler.java
- Responsibility: Orchestrates payment recording with invoice balance update
- Dependencies: PaymentRepository, InvoiceRepository, PaymentService
- Transaction Boundary: @Transactional ensures atomic payment + invoice update
- Key Logic:
  1. Fetch invoice (fail if not found)
  2. Validate invoice status (must be Sent)
  3. Create Payment entity
  4. Validate payment against invoice (PaymentService)
  5. Calculate new balance
  6. Update invoice balance
  7. Mark invoice as Paid if balance = 0
  8. Save payment
  9. Save invoice
  10. Publish PaymentRecorded event
  11. Return PaymentResponseDTO

**PaymentCommandController** [Derived from PRD Epic 3 Story 3.2 AC 5]:
- Location: backend/src/main/java/com/invoiceme/features/payment/api/PaymentCommandController.java
- Responsibility: REST API endpoint for payment recording
- Endpoint: POST /api/invoices/{id}/payments
- Authentication: Required (JWT token)
- Request Validation: @Valid annotation triggers DTO validation
- Error Handling: GlobalExceptionHandler catches exceptions and formats responses

**IdempotencyService** [Derived from PRD Epic 3 Story 3.2 AC 8]:
- Location: backend/src/main/java/com/invoiceme/common/idempotency/IdempotencyService.java
- Responsibility: Prevent duplicate payment recording with idempotency keys
- Key Methods:
  - `checkIdempotency(String key)` - Returns cached response if key exists
  - `storeIdempotency(String key, Object response, Duration ttl)` - Stores response with expiration
- Storage: IdempotencyRecord entity in database or Redis cache
- TTL: 24 hours (configurable)
- Note: Optional feature - idempotency key not required for all requests

### File Locations

**Backend Files** [Source: architecture.md#Unified Project Structure]:
```
backend/src/main/java/com/invoiceme/features/payment/
├── commands/
│   ├── RecordPaymentCommand.java          # Immutable command DTO
│   ├── RecordPaymentDTO.java              # REST API request DTO
│   └── RecordPaymentCommandHandler.java   # Command handler with @Transactional
├── domain/
│   ├── Payment.java                        # Enhanced from Story 3.1
│   ├── PaymentService.java                # Enhanced from Story 3.1
│   └── events/
│       └── PaymentRecorded.java           # Domain event
├── api/
│   └── PaymentCommandController.java      # REST controller
└── exceptions/
    ├── InvoiceNotSentException.java       # Business rule exception
    └── PaymentExceedsBalanceException.java # Business rule exception

backend/src/main/java/com/invoiceme/features/invoice/domain/
└── Invoice.java                            # Add applyPayment(), markAsPaid() methods

backend/src/main/java/com/invoiceme/common/
├── idempotency/
│   ├── IdempotencyRecord.java             # Entity for idempotency tracking
│   ├── IdempotencyRepository.java         # Repository interface
│   └── IdempotencyService.java            # Service for idempotency logic
└── exceptions/
    └── GlobalExceptionHandler.java        # Add payment exception handlers

backend/src/test/java/com/invoiceme/features/payment/
├── commands/
│   ├── RecordPaymentCommandHandlerTest.java   # Integration tests
│   └── RecordPaymentCommandTest.java          # Unit tests
└── api/
    └── PaymentCommandControllerTest.java      # API integration tests
```

### Testing Requirements

**Testing Strategy** [Source: architecture.md#Tech Stack, PRD Technical Assumptions]:
- Integration tests for command handler (full transaction testing)
- API tests for REST controller (MockMvc)
- Unit tests for domain logic enhancements (Invoice.applyPayment)
- Test transactional rollback on failures
- Test concurrent payment scenarios (optimistic locking)
- Test idempotency with duplicate requests
- Minimum 90% code coverage on payment command logic

**Integration Test Structure**:
```java
@SpringBootTest
@Transactional
@DisplayName("RecordPaymentCommandHandler Integration Tests")
class RecordPaymentCommandHandlerTest {

    @Autowired
    private RecordPaymentCommandHandler handler;

    @Autowired
    private InvoiceRepository invoiceRepository;

    @Autowired
    private PaymentRepository paymentRepository;

    @Test
    @DisplayName("Should record payment and update invoice balance")
    void shouldRecordPaymentAndUpdateInvoiceBalance() {
        // Given: Invoice with balance of $500
        Invoice invoice = InvoiceTestBuilder.aInvoice()
            .withStatus(InvoiceStatus.SENT)
            .withTotalAmount(new BigDecimal("500.00"))
            .withBalance(new BigDecimal("500.00"))
            .build();
        invoice = invoiceRepository.save(invoice);

        RecordPaymentCommand command = new RecordPaymentCommand(
            invoice.getId(),
            LocalDate.now(),
            new BigDecimal("200.00"),
            PaymentMethod.CREDIT_CARD,
            "REF-123",
            "Partial payment",
            null
        );

        // When: Record payment
        PaymentResponseDTO response = handler.handle(command, "user@example.com");

        // Then: Payment created and invoice balance updated
        assertThat(response).isNotNull();
        assertThat(response.amount()).isEqualByComparingTo(new BigDecimal("200.00"));
        assertThat(response.remainingBalance()).isEqualByComparingTo(new BigDecimal("300.00"));

        Invoice updatedInvoice = invoiceRepository.findById(invoice.getId()).orElseThrow();
        assertThat(updatedInvoice.getBalance()).isEqualByComparingTo(new BigDecimal("300.00"));
        assertThat(updatedInvoice.getStatus()).isEqualTo(InvoiceStatus.SENT);

        List<Payment> payments = paymentRepository.findByInvoiceId(invoice.getId());
        assertThat(payments).hasSize(1);
    }

    @Test
    @DisplayName("Should mark invoice as Paid when balance reaches zero")
    void shouldMarkInvoiceAsPaidWhenBalanceReachesZero() {
        // Given: Invoice with balance of $200
        Invoice invoice = InvoiceTestBuilder.aInvoice()
            .withStatus(InvoiceStatus.SENT)
            .withTotalAmount(new BigDecimal("200.00"))
            .withBalance(new BigDecimal("200.00"))
            .build();
        invoice = invoiceRepository.save(invoice);

        RecordPaymentCommand command = new RecordPaymentCommand(
            invoice.getId(),
            LocalDate.now(),
            new BigDecimal("200.00"),
            PaymentMethod.BANK_TRANSFER,
            "REF-456",
            "Full payment",
            null
        );

        // When: Record full payment
        PaymentResponseDTO response = handler.handle(command, "user@example.com");

        // Then: Invoice marked as Paid
        Invoice updatedInvoice = invoiceRepository.findById(invoice.getId()).orElseThrow();
        assertThat(updatedInvoice.getBalance()).isEqualByComparingTo(BigDecimal.ZERO);
        assertThat(updatedInvoice.getStatus()).isEqualTo(InvoiceStatus.PAID);
    }

    @Test
    @DisplayName("Should throw exception when payment applied to Draft invoice")
    void shouldThrowExceptionWhenPaymentAppliedToDraftInvoice() {
        // Given: Draft invoice
        Invoice invoice = InvoiceTestBuilder.aInvoice()
            .withStatus(InvoiceStatus.DRAFT)
            .build();
        invoice = invoiceRepository.save(invoice);

        RecordPaymentCommand command = new RecordPaymentCommand(
            invoice.getId(),
            LocalDate.now(),
            new BigDecimal("100.00"),
            PaymentMethod.CASH,
            "REF-789",
            null,
            null
        );

        // When/Then: Recording payment should fail
        assertThatThrownBy(() -> handler.handle(command, "user@example.com"))
            .isInstanceOf(InvoiceNotSentException.class)
            .hasMessageContaining("Invoice must be in Sent status");

        // Verify no payment was created
        List<Payment> payments = paymentRepository.findByInvoiceId(invoice.getId());
        assertThat(payments).isEmpty();
    }

    @Test
    @DisplayName("Should throw exception when payment exceeds balance")
    void shouldThrowExceptionWhenPaymentExceedsBalance() {
        // Given: Invoice with balance of $100
        Invoice invoice = InvoiceTestBuilder.aInvoice()
            .withStatus(InvoiceStatus.SENT)
            .withBalance(new BigDecimal("100.00"))
            .build();
        invoice = invoiceRepository.save(invoice);

        RecordPaymentCommand command = new RecordPaymentCommand(
            invoice.getId(),
            LocalDate.now(),
            new BigDecimal("150.00"),  // Exceeds balance
            PaymentMethod.CHECK,
            "REF-999",
            null,
            null
        );

        // When/Then: Recording payment should fail
        assertThatThrownBy(() -> handler.handle(command, "user@example.com"))
            .isInstanceOf(PaymentExceedsBalanceException.class)
            .hasMessageContaining("Payment amount exceeds invoice balance");

        // Verify transaction rolled back (no payment, invoice unchanged)
        List<Payment> payments = paymentRepository.findByInvoiceId(invoice.getId());
        assertThat(payments).isEmpty();

        Invoice unchangedInvoice = invoiceRepository.findById(invoice.getId()).orElseThrow();
        assertThat(unchangedInvoice.getBalance()).isEqualByComparingTo(new BigDecimal("100.00"));
    }

    @Test
    @DisplayName("Should prevent duplicate payment with idempotency key")
    void shouldPreventDuplicatePaymentWithIdempotencyKey() {
        // Given: Invoice and idempotency key
        Invoice invoice = InvoiceTestBuilder.aInvoice()
            .withStatus(InvoiceStatus.SENT)
            .withBalance(new BigDecimal("500.00"))
            .build();
        invoice = invoiceRepository.save(invoice);

        String idempotencyKey = "payment-test-001";
        RecordPaymentCommand command = new RecordPaymentCommand(
            invoice.getId(),
            LocalDate.now(),
            new BigDecimal("100.00"),
            PaymentMethod.CREDIT_CARD,
            "REF-IDM",
            null,
            idempotencyKey
        );

        // When: Record payment twice with same idempotency key
        PaymentResponseDTO response1 = handler.handle(command, "user@example.com");
        PaymentResponseDTO response2 = handler.handle(command, "user@example.com");

        // Then: Only one payment created, same response returned
        assertThat(response1.id()).isEqualTo(response2.id());

        List<Payment> payments = paymentRepository.findByInvoiceId(invoice.getId());
        assertThat(payments).hasSize(1);  // Only one payment despite two requests

        Invoice updatedInvoice = invoiceRepository.findById(invoice.getId()).orElseThrow();
        assertThat(updatedInvoice.getBalance()).isEqualByComparingTo(new BigDecimal("400.00"));
    }
}
```

**API Test Structure**:
```java
@WebMvcTest(PaymentCommandController.class)
@DisplayName("PaymentCommandController API Tests")
class PaymentCommandControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private RecordPaymentCommandHandler handler;

    @Test
    @WithMockUser(username = "user@example.com")
    @DisplayName("POST /api/invoices/{id}/payments should return 201 Created")
    void shouldRecordPaymentSuccessfully() throws Exception {
        UUID invoiceId = UUID.randomUUID();
        PaymentResponseDTO responseDTO = new PaymentResponseDTO(
            UUID.randomUUID(),
            invoiceId,
            "INV-2024-0001",
            "Acme Corp",
            LocalDate.now(),
            new BigDecimal("100.00"),
            PaymentMethod.CREDIT_CARD,
            "REF-123",
            null,
            new BigDecimal("400.00"),
            LocalDateTime.now(),
            "user@example.com"
        );

        when(handler.handle(any(RecordPaymentCommand.class), eq("user@example.com")))
            .thenReturn(responseDTO);

        mockMvc.perform(post("/api/invoices/{id}/payments", invoiceId)
                .contentType(MediaType.APPLICATION_JSON)
                .content("""
                    {
                      "paymentDate": "2024-11-08",
                      "amount": 100.00,
                      "paymentMethod": "CreditCard",
                      "reference": "REF-123"
                    }
                    """))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.id").exists())
            .andExpect(jsonPath("$.amount").value(100.00))
            .andExpect(jsonPath("$.remainingBalance").value(400.00));
    }

    @Test
    @WithMockUser
    @DisplayName("POST with invalid payload should return 400 Bad Request")
    void shouldReturnBadRequestForInvalidPayload() throws Exception {
        UUID invoiceId = UUID.randomUUID();

        mockMvc.perform(post("/api/invoices/{id}/payments", invoiceId)
                .contentType(MediaType.APPLICATION_JSON)
                .content("""
                    {
                      "paymentDate": "2024-11-08",
                      "amount": -50.00,
                      "paymentMethod": "CreditCard"
                    }
                    """))
            .andExpect(status().isBadRequest())
            .andExpect(jsonPath("$.errors").isArray())
            .andExpect(jsonPath("$.errors[0].field").value("amount"))
            .andExpect(jsonPath("$.errors[0].message").value("must be greater than 0"));
    }

    @Test
    @DisplayName("POST without authentication should return 401 Unauthorized")
    void shouldReturnUnauthorizedWithoutAuthentication() throws Exception {
        UUID invoiceId = UUID.randomUUID();

        mockMvc.perform(post("/api/invoices/{id}/payments", invoiceId)
                .contentType(MediaType.APPLICATION_JSON)
                .content("""
                    {
                      "paymentDate": "2024-11-08",
                      "amount": 100.00,
                      "paymentMethod": "CreditCard"
                    }
                    """))
            .andExpect(status().isUnauthorized());
    }
}
```

### Technical Constraints

**Dependencies** [Source: architecture.md#Tech Stack]:
- Spring Boot 3.2.x
- Spring Data JPA
- Spring Security for authentication
- Spring Transactions (@Transactional)
- Jakarta Validation for DTO validation
- PostgreSQL 15
- Flyway for migrations (if needed)
- JUnit 5, Mockito, AssertJ for testing
- TestContainers for integration tests

**Transaction Management** [Source: PRD Epic 3 Story 3.2 AC 6]:
- @Transactional on RecordPaymentCommandHandler.handle()
- Isolation level: READ_COMMITTED (Spring default)
- Propagation: REQUIRED (join existing or create new)
- Rollback on: All exceptions (default behavior)
- Transaction scope includes:
  - Payment creation
  - Invoice balance update
  - Invoice status update (if applicable)
  - Event publishing (if transactional)
- Atomic guarantee: Both payment and invoice updated together or neither

**Idempotency** [Source: PRD Epic 3 Story 3.2 AC 8]:
- Optional feature via idempotency key
- Storage: Database table or Redis cache
- Key format: Client-provided string (e.g., UUID or semantic key)
- TTL: 24 hours (configurable)
- Behavior:
  - If key exists and not expired: Return cached response (200 OK)
  - If key doesn't exist: Process command, store response with key
  - If key expired: Process as new request
- Use case: Prevent duplicate payments from retry logic or network issues

**Performance Requirements** [Source: PRD NFR1]:
- Payment recording API response time: <200ms
- Database indexes on payments.invoice_id for fast lookup
- Minimize transaction duration (no external calls within transaction)
- Use optimistic locking to handle concurrent payments
- Profile and optimize slow queries

**Security** [Source: PRD Epic 1 Story 1.2]:
- JWT authentication required for POST /api/invoices/{id}/payments
- Validate user has permission to record payment for invoice
- Audit trail: createdBy field records user who made payment
- Input validation at multiple layers (DTO, domain)
- Prevent SQL injection via parameterized queries (JPA default)

### Coding Standards

**Critical Backend Rules** [Source: architecture.md#Coding Standards]:
- Transaction Boundaries: @Transactional at handler level, not controller
- CQRS Separation: Commands modify state, queries do not (this is a command)
- Domain Logic in Entities: Invoice.applyPayment() encapsulates business rules
- DTO Pattern: Never expose domain entities via API, use DTOs
- Validation Layers: Validate in DTO, domain, and service layers
- Immutable Commands: Use Java records for command DTOs
- Event Publishing: Publish domain events for cross-aggregate communication

**Error Handling Pattern** [Source: architecture.md#Components, PRD Story 4.2]:
- Controller catches exceptions via GlobalExceptionHandler
- Domain exceptions for business rule violations
- Standard error response format: ApiErrorResponse
- Include field-level errors for validation failures
- Log exceptions with context (correlation ID, user, invoice ID)

**Testing Best Practices**:
- Integration tests for command handlers (full stack)
- API tests for controllers (MockMvc)
- Use test data builders for setup (InvoiceTestBuilder, PaymentTestBuilder)
- Test happy path and error scenarios
- Test transactional rollback on failures
- Test concurrent scenarios (race conditions)
- Achieve >90% code coverage on command logic

**Logging Standards** [Source: architecture.md#Components]:
- Use SLF4J Logger
- Log levels:
  - INFO: Successful payment recording, invoice status changes
  - WARN: Business rule violations (payment to draft invoice)
  - ERROR: Unexpected exceptions, transaction failures
- Include correlation ID in logs (MDC)
- Avoid logging sensitive payment details in production

### Relationship with Other Domains

**Payment → Invoice** [Source: architecture.md#Data Models]:
- Payment modifies Invoice aggregate (updates balance and status)
- Cross-aggregate transaction managed by command handler
- Invoice repository injected into payment command handler
- Invoice.applyPayment() method called to update balance
- Invoice.markAsPaid() method called when balance reaches zero

**Payment → Customer** [Source: architecture.md#Data Models]:
- Indirect relationship through Invoice
- Customer not directly modified by payment recording
- Customer name included in PaymentResponseDTO for display

**Event Publishing** [Source: PRD Epic 3 Story 3.2 AC 7]:
- PaymentRecorded event published after successful payment
- Event contains payment and invoice information
- Can be used for:
  - Audit logging
  - Email notifications (future)
  - Analytics and reporting (future)
  - Event sourcing (if implemented)
- Event publishing infrastructure may not exist yet (log event for now)

## Testing
- Integration tests for RecordPaymentCommandHandler
- Test successful payment recording updates invoice balance
- Test full payment marks invoice as Paid
- Test partial payment leaves invoice in Sent status
- Test payment on Draft invoice throws exception
- Test payment exceeding balance throws exception
- Test negative payment amount throws validation exception
- Test future payment date throws validation exception
- Test missing required fields throws validation exception
- Test idempotency prevents duplicate payments
- Test transaction rollback on validation failure
- API tests for PaymentCommandController
- Test POST /api/invoices/{id}/payments returns 201 Created
- Test POST with invalid payload returns 400 Bad Request
- Test POST without authentication returns 401 Unauthorized
- Test POST with invalid invoice ID returns 404 Not Found
- Test error response format matches ApiErrorResponse
- Unit tests for Invoice.applyPayment() and markAsPaid()
- Test invoice balance update logic
- Test invoice status transition logic
- Test validation of payment against invoice state
- Performance tests for payment recording (<200ms)
- Concurrent payment tests (optimistic locking)
- Minimum 90% code coverage on payment command logic

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-11-08 | v1.0 | Initial story creation from PRD Epic 3 Story 3.2 | Claude (Story Agent) |

## Dev Agent Record

### Agent Model Used
Not yet implemented

### Debug Log References
None yet - will be populated during implementation

### Completion Notes List
None yet - will be populated during implementation

### File List
None yet - will be populated during implementation

## QA Results
Not yet reviewed
