# Story 2.3: Invoice Queries & Calculations

## Status
Draft

## Story
**As a** developer,
**I want** to implement Invoice query models with computed fields,
**so that** we can efficiently retrieve invoice data with calculations.

## Acceptance Criteria
1. GetInvoiceByIdQuery returns full invoice with line items and calculations
2. ListInvoicesQuery with filters: by customer, status, date range
3. InvoiceResponseDTO includes computed: subtotal, tax, total, balance due
4. Query projections optimize for common read patterns
5. REST endpoints: GET /api/invoices/{id}, GET /api/invoices
6. Dashboard query for invoice statistics (count by status, total amounts)
7. Export-friendly query format for invoice details
8. Performance: invoice list query under 100ms for 1000 records

## Tasks / Subtasks
- [ ] Create GetInvoiceByIdQuery and handler (AC: 1, 3, 4)
  - [ ] Create GetInvoiceByIdQuery record in queries/ package
  - [ ] Add field: UUID invoiceId
  - [ ] Create GetInvoiceByIdQueryHandler class
  - [ ] Inject InvoiceRepository and CustomerRepository
  - [ ] Load invoice by ID (throw InvoiceNotFoundException if not found)
  - [ ] Load customer details for invoice (join or separate query)
  - [ ] Convert Invoice entity to InvoiceResponseDTO with all computed fields
  - [ ] Include customer name and email in response
  - [ ] Calculate daysOverdue if status != Paid and today > dueDate
  - [ ] Convert all LineItem entities to LineItemResponseDTO with calculations
  - [ ] Return complete InvoiceResponseDTO
  - [ ] Unit tests for GetInvoiceByIdQueryHandler
  - [ ] Test successful retrieval with all fields populated
  - [ ] Test InvoiceNotFoundException when invoice doesn't exist
  - [ ] Test customer data is included in response
  - [ ] Test daysOverdue calculation for overdue invoices
  - [ ] Test daysOverdue is null for paid or non-overdue invoices

- [ ] Create ListInvoicesQuery and handler (AC: 2, 4, 8)
  - [ ] Create ListInvoicesQuery record in queries/
  - [ ] Add fields: UUID customerId (optional), InvoiceStatus status (optional), LocalDate startDate (optional), LocalDate endDate (optional)
  - [ ] Add pagination fields: int page (default 0), int size (default 20)
  - [ ] Add sorting fields: String sortBy (default "issueDate"), String sortDirection (default "DESC")
  - [ ] Create ListInvoicesQueryHandler class
  - [ ] Inject InvoiceRepository
  - [ ] Build dynamic query based on filters (using Specification or Criteria API)
  - [ ] Filter by customerId if provided
  - [ ] Filter by status if provided
  - [ ] Filter by date range (issueDate >= startDate AND issueDate <= endDate)
  - [ ] Apply pagination (PageRequest.of(page, size, Sort))
  - [ ] Execute query and get Page<Invoice>
  - [ ] Convert each Invoice to InvoiceListItemDTO (lightweight version)
  - [ ] InvoiceListItemDTO includes: id, invoiceNumber, customerName, issueDate, dueDate, status, totalAmount, balance
  - [ ] Return PagedResult<InvoiceListItemDTO> with page metadata
  - [ ] Optimize query with JOIN FETCH for customer to avoid N+1
  - [ ] Unit tests for ListInvoicesQueryHandler
  - [ ] Test filtering by customer returns only that customer's invoices
  - [ ] Test filtering by status (Draft, Sent, Paid) works correctly
  - [ ] Test date range filtering
  - [ ] Test combined filters (customer + status + date range)
  - [ ] Test pagination returns correct page size and number
  - [ ] Test sorting by different fields (issueDate, invoiceNumber, dueDate)
  - [ ] Test empty results when no invoices match filters

- [ ] Create GetDashboardStatsQuery and handler (AC: 6)
  - [ ] Create GetDashboardStatsQuery record (no parameters, or optional date range)
  - [ ] Create DashboardStatsDTO record
  - [ ] Add fields: totalCustomers, totalInvoices, draftInvoices, sentInvoices, paidInvoices
  - [ ] Add fields: totalRevenue (sum of paid invoices), outstandingAmount (sum of sent invoice balances), overdueAmount
  - [ ] Create GetDashboardStatsQueryHandler class
  - [ ] Inject InvoiceRepository and CustomerRepository
  - [ ] Query customer count: SELECT COUNT(*) FROM customers WHERE is_deleted = false
  - [ ] Query invoice counts by status using GROUP BY or separate counts
  - [ ] Query total revenue: SUM(total_amount) WHERE status = 'Paid'
  - [ ] Query outstanding amount: SUM(balance) WHERE status = 'Sent'
  - [ ] Query overdue amount: SUM(balance) WHERE status = 'Sent' AND due_date < CURRENT_DATE
  - [ ] Assemble DashboardStatsDTO with all calculated values
  - [ ] Return DashboardStatsDTO
  - [ ] Unit tests for GetDashboardStatsQueryHandler
  - [ ] Test counts are accurate for different invoice statuses
  - [ ] Test revenue calculation from paid invoices
  - [ ] Test outstanding amount from sent invoices
  - [ ] Test overdue calculation based on due date

- [ ] Create Query DTOs (AC: 3, 7)
  - [ ] InvoiceResponseDTO already defined in Story 2.2, ensure it's in queries/dto/ or shared dto/
  - [ ] Create InvoiceListItemDTO record (lightweight for lists)
  - [ ] Fields: id, invoiceNumber, customerId, customerName, issueDate, dueDate, status, totalAmount, balance, version
  - [ ] Create DashboardStatsDTO record
  - [ ] Fields: totalCustomers, totalInvoices, draftInvoices, sentInvoices, paidInvoices, totalRevenue, outstandingAmount, overdueAmount
  - [ ] Create PagedResult<T> generic record for pagination metadata
  - [ ] Fields: List<T> content, int page, int size, long totalElements, int totalPages
  - [ ] Create InvoiceMapper utility class if not exists
  - [ ] Add method: toInvoiceResponseDTO(Invoice, Customer)
  - [ ] Add method: toInvoiceListItemDTO(Invoice)
  - [ ] Add method: toLineItemResponseDTO(LineItem)
  - [ ] Ensure all calculated fields are properly mapped from domain entities
  - [ ] Calculated fields: subtotal, totalDiscount, totalTax, totalAmount, balance (from Invoice aggregate)
  - [ ] LineItem calculated fields: subtotal, discountAmount, taxableAmount, taxAmount, total

- [ ] Implement InvoiceQueryController (AC: 5)
  - [ ] Create InvoiceQueryController class in api/
  - [ ] Annotate with @RestController and @RequestMapping("/api/invoices")
  - [ ] Inject query handlers (GetInvoiceByIdQueryHandler, ListInvoicesQueryHandler)
  - [ ] Implement GET /api/invoices/{id} endpoint
  - [ ] Accept @PathVariable UUID id
  - [ ] Create GetInvoiceByIdQuery with id
  - [ ] Call GetInvoiceByIdQueryHandler
  - [ ] Return 200 OK with InvoiceResponseDTO
  - [ ] Handle InvoiceNotFoundException -> 404 Not Found
  - [ ] Implement GET /api/invoices endpoint
  - [ ] Accept @RequestParam filters: customerId, status, startDate, endDate, page, size, sortBy, sortDirection
  - [ ] All request params are optional
  - [ ] Create ListInvoicesQuery with all filters
  - [ ] Call ListInvoicesQueryHandler
  - [ ] Return 200 OK with PagedResult<InvoiceListItemDTO>
  - [ ] Add Swagger/OpenAPI annotations for documentation
  - [ ] Document all query parameters with descriptions
  - [ ] Add proper security (JWT auth required)

- [ ] Implement DashboardController (AC: 6)
  - [ ] Create DashboardController class in api/ (or separate dashboard package)
  - [ ] Annotate with @RestController and @RequestMapping("/api/dashboard")
  - [ ] Inject GetDashboardStatsQueryHandler
  - [ ] Implement GET /api/dashboard/stats endpoint
  - [ ] Create GetDashboardStatsQuery (empty or with optional filters)
  - [ ] Call GetDashboardStatsQueryHandler
  - [ ] Return 200 OK with DashboardStatsDTO
  - [ ] Add Swagger/OpenAPI annotations
  - [ ] Add JWT authentication requirement

- [ ] Optimize query performance (AC: 4, 8)
  - [ ] Review database indexes from Story 2.1
  - [ ] Ensure index on invoices(customer_id) exists
  - [ ] Ensure index on invoices(status) exists
  - [ ] Ensure index on invoices(issue_date) exists
  - [ ] Ensure index on invoices(due_date) exists
  - [ ] Use JOIN FETCH in JPQL to fetch customer with invoice (avoid N+1)
  - [ ] Example: "SELECT i FROM Invoice i JOIN FETCH i.customer WHERE i.id = :id"
  - [ ] For list queries, use projections to select only needed fields
  - [ ] Test query performance with 1000+ invoice records
  - [ ] Ensure list query returns in under 100ms (NFR8)
  - [ ] Use @Query with native SQL if JPQL is too slow
  - [ ] Consider using Spring Data JPA projections for InvoiceListItemDTO
  - [ ] Document any performance optimizations in code comments

- [ ] Write comprehensive integration tests (AC: all)
  - [ ] Create InvoiceQueryIntegrationTest class
  - [ ] Use @SpringBootTest or @WebMvcTest for controller tests
  - [ ] Test GET /api/invoices/{id} returns full invoice details
  - [ ] Test GET /api/invoices/{id} returns 404 for non-existent invoice
  - [ ] Test GET /api/invoices with no filters returns all invoices
  - [ ] Test GET /api/invoices?customerId={id} filters by customer
  - [ ] Test GET /api/invoices?status=Draft returns only draft invoices
  - [ ] Test GET /api/invoices?status=Sent returns only sent invoices
  - [ ] Test GET /api/invoices?startDate=2024-01-01&endDate=2024-12-31 filters by date range
  - [ ] Test GET /api/invoices with pagination (page=0&size=10)
  - [ ] Test GET /api/invoices returns correct page metadata (totalElements, totalPages)
  - [ ] Test GET /api/invoices?sortBy=invoiceNumber&sortDirection=ASC sorts correctly
  - [ ] Test GET /api/dashboard/stats returns correct statistics
  - [ ] Test dashboard stats calculate counts and amounts correctly
  - [ ] Verify InvoiceResponseDTO includes all computed fields
  - [ ] Verify LineItemResponseDTO includes all calculated fields
  - [ ] Verify daysOverdue is calculated for overdue invoices
  - [ ] Use MockMvc for API endpoint testing
  - [ ] Use AssertJ for fluent assertions

- [ ] Add query handler unit tests
  - [ ] Unit test GetInvoiceByIdQueryHandler with mocked repository
  - [ ] Mock InvoiceRepository.findById() to return test invoice
  - [ ] Mock CustomerRepository to return customer
  - [ ] Verify InvoiceResponseDTO is populated correctly
  - [ ] Verify all calculated fields are present
  - [ ] Test exception when invoice not found
  - [ ] Unit test ListInvoicesQueryHandler with mocked repository
  - [ ] Mock repository to return page of invoices
  - [ ] Test filters are applied correctly (verify repository method calls)
  - [ ] Test pagination parameters are passed correctly
  - [ ] Test sorting parameters are applied
  - [ ] Verify DTO conversion for list items
  - [ ] Unit test GetDashboardStatsQueryHandler with mocked repositories
  - [ ] Mock repository queries to return test counts and sums
  - [ ] Verify stats DTO is assembled correctly
  - [ ] Test all statistics fields are calculated

- [ ] Create custom repository methods if needed (AC: 4, 6, 8)
  - [ ] If InvoiceRepository needs custom queries, create InvoiceRepositoryCustom interface
  - [ ] Implement custom methods in InvoiceRepositoryImpl
  - [ ] Add method: findWithFilters(customerId, status, startDate, endDate, Pageable)
  - [ ] Use Criteria API or @Query annotation for dynamic filtering
  - [ ] Add method for dashboard stats: getDashboardStatistics()
  - [ ] Return stats as Object[] or dedicated projection
  - [ ] Ensure custom queries are optimized with proper indexes
  - [ ] Test custom repository methods with @DataJpaTest

## Dev Notes

### Previous Story Insights
**Story 2.2 Completion:**
Story 2.2 will have implemented the Invoice command operations:
- CreateInvoiceCommand, UpdateInvoiceCommand, SendInvoiceCommand with handlers
- InvoiceCommandController with POST, PUT, POST /send endpoints
- InvoiceResponseDTO, LineItemResponseDTO, CreateInvoiceDTO, UpdateInvoiceDTO, LineItemDTO
- InvoiceMapper utility for DTO conversions
- Domain exceptions: InvoiceNotFoundException, InvoiceValidationException
- Optimistic locking with @Version field
- Integration tests for all command flows
- Validation at DTO, handler, and domain levels

**Story 2.1 Completion:**
Story 2.1 implemented the Invoice domain model:
- Invoice aggregate root with all business logic
- LineItem value object with calculations (subtotal, discountAmount, taxableAmount, taxAmount, total)
- Invoice methods: addLineItem(), removeLineItem(), calculateTotals()
- Invoice state transitions: markAsSent(), markAsPaid()
- InvoiceRepository interface in domain/
- JpaInvoiceRepository implementation with JSONB for line items
- InvoiceNumberGenerator for sequential numbering (INV-YYYY-NNNN)
- Database table with indexes on customer_id, status, issue_date, due_date, invoice_number

**Key Technical Patterns Established:**
From Epic 1 Customer domain:
- Queries placed in features/{feature}/queries/ package
- Query handlers implement read logic and call repository
- DTOs optimized for UI consumption (may include joined data from multiple aggregates)
- Controllers delegate to query handlers
- Repository pattern: inject repository interfaces, not implementations
- Use Java records for immutable DTOs and queries
- Query results can include computed/calculated fields
- Separate read models (DTOs) from domain entities
- Query optimization using indexes, JOIN FETCH, projections

### Data Models

**GetInvoiceByIdQuery** [Derived from PRD Epic 2 Story 2.3 AC 1]:
```java
public record GetInvoiceByIdQuery(
    UUID invoiceId
) {}
```

**ListInvoicesQuery** [Derived from PRD Epic 2 Story 2.3 AC 2]:
```java
public record ListInvoicesQuery(
    UUID customerId,        // Optional filter
    InvoiceStatus status,   // Optional filter
    LocalDate startDate,    // Optional filter
    LocalDate endDate,      // Optional filter
    int page,               // Default 0
    int size,               // Default 20
    String sortBy,          // Default "issueDate"
    String sortDirection    // Default "DESC"
) {
    // Compact constructor for defaults
    public ListInvoicesQuery {
        if (page < 0) page = 0;
        if (size <= 0) size = 20;
        if (sortBy == null || sortBy.isBlank()) sortBy = "issueDate";
        if (sortDirection == null || sortDirection.isBlank()) sortDirection = "DESC";
    }
}
```

**GetDashboardStatsQuery** [Derived from PRD Epic 2 Story 2.3 AC 6]:
```java
public record GetDashboardStatsQuery() {
    // No parameters for now - returns all-time stats
    // Could add optional date range filters in future
}
```

**InvoiceResponseDTO** [Source: architecture.md#Data Models]:
Already defined in Story 2.2, should be shared between commands and queries:
```java
public record InvoiceResponseDTO(
    UUID id,
    String invoiceNumber,
    UUID customerId,
    String customerName,      // Joined from Customer
    String customerEmail,     // Joined from Customer
    LocalDate issueDate,
    LocalDate dueDate,
    InvoiceStatus status,
    String paymentTerms,

    // Calculated totals (from Invoice aggregate)
    BigDecimal subtotal,
    BigDecimal totalDiscount,
    BigDecimal totalTax,
    BigDecimal totalAmount,
    BigDecimal balance,

    List<LineItemResponseDTO> lineItems,
    String notes,
    Long version,  // For optimistic locking
    Instant createdAt,
    Instant updatedAt,

    Integer daysOverdue  // Calculated: if status != Paid and today > dueDate
) {}
```

**InvoiceListItemDTO** [Derived from PRD Epic 2 Story 2.3 AC 2]:
Lightweight DTO for list views (no line items):
```java
public record InvoiceListItemDTO(
    UUID id,
    String invoiceNumber,
    UUID customerId,
    String customerName,      // Joined
    LocalDate issueDate,
    LocalDate dueDate,
    InvoiceStatus status,
    BigDecimal totalAmount,
    BigDecimal balance,
    Long version,
    Integer daysOverdue       // Calculated
) {}
```

**LineItemResponseDTO** [Source: architecture.md#Data Models]:
Already defined in Story 2.2:
```java
public record LineItemResponseDTO(
    String id,
    String description,
    int quantity,
    BigDecimal unitPrice,
    BigDecimal discountPercent,
    BigDecimal taxRate,

    // Calculated fields (from LineItem value object)
    BigDecimal subtotal,
    BigDecimal discountAmount,
    BigDecimal taxableAmount,
    BigDecimal taxAmount,
    BigDecimal total
) {}
```

**DashboardStatsDTO** [Derived from PRD Epic 2 Story 2.3 AC 6]:
```java
public record DashboardStatsDTO(
    int totalCustomers,
    int totalInvoices,
    int draftInvoices,
    int sentInvoices,
    int paidInvoices,
    BigDecimal totalRevenue,      // Sum of paid invoice amounts
    BigDecimal outstandingAmount, // Sum of sent invoice balances
    BigDecimal overdueAmount      // Sum of overdue sent invoice balances
) {}
```

**PagedResult<T>** [Derived from PRD Epic 2 Story 2.3 AC 2]:
Generic pagination wrapper:
```java
public record PagedResult<T>(
    List<T> content,
    int page,
    int size,
    long totalElements,
    int totalPages
) {
    // Factory method from Spring Data Page
    public static <T> PagedResult<T> from(Page<T> springPage) {
        return new PagedResult<>(
            springPage.getContent(),
            springPage.getNumber(),
            springPage.getSize(),
            springPage.getTotalElements(),
            springPage.getTotalPages()
        );
    }
}
```

### API Specifications

**Invoice Query Endpoints** [Source: architecture.md#REST API Specification]:

**GET /api/invoices/{id}** (Get Invoice by ID Query)
- Path: id (UUID)
- Response: 200 OK with InvoiceResponseDTO
- Auth: Bearer token required
- Returns: Full invoice details with line items, customer info, calculations
- Computed fields included: subtotal, totalDiscount, totalTax, totalAmount, balance, daysOverdue
- Errors:
  - 404 Not Found if invoice doesn't exist
  - 401 Unauthorized if no/invalid token

**GET /api/invoices** (List Invoices Query)
- Query Parameters (all optional):
  - customerId: UUID - Filter by customer
  - status: InvoiceStatus (Draft, Sent, Paid) - Filter by status
  - startDate: LocalDate - Filter issue date >= startDate
  - endDate: LocalDate - Filter issue date <= endDate
  - page: int (default 0) - Page number
  - size: int (default 20) - Page size
  - sortBy: string (default "issueDate") - Sort field
  - sortDirection: string (default "DESC") - Sort direction (ASC/DESC)
- Response: 200 OK with PagedResult<InvoiceListItemDTO>
- Auth: Bearer token required
- Returns: Paginated list of invoices with filtering and sorting
- Optimized for performance (no line items in list, joined customer name)
- Errors:
  - 400 Bad Request if invalid query parameters
  - 401 Unauthorized if no/invalid token

**GET /api/dashboard/stats** (Dashboard Statistics Query)
- Response: 200 OK with DashboardStatsDTO
- Auth: Bearer token required
- Returns: Aggregate statistics for dashboard display
- Statistics: invoice counts by status, revenue, outstanding amounts
- Errors:
  - 401 Unauthorized if no/invalid token

[Source: architecture.md#API Specification - REST API Specification]

### Component Specifications

**Invoice Query Module Structure** [Source: architecture.md#Components - Invoice Vertical Slice]:
```
backend/src/main/java/com/invoiceme/features/invoice/
  ├── queries/
  │   ├── GetInvoiceByIdQuery.java (record)
  │   ├── GetInvoiceByIdQueryHandler.java
  │   ├── ListInvoicesQuery.java (record)
  │   ├── ListInvoicesQueryHandler.java
  │   ├── GetDashboardStatsQuery.java (record)
  │   ├── GetDashboardStatsQueryHandler.java
  │   └── dto/
  │       ├── InvoiceResponseDTO.java (shared with commands)
  │       ├── InvoiceListItemDTO.java
  │       ├── LineItemResponseDTO.java (shared with commands)
  │       ├── DashboardStatsDTO.java
  │       ├── PagedResult.java (generic, could be in common/)
  │       └── InvoiceMapper.java (shared utility)
  ├── api/
  │   ├── InvoiceQueryController.java
  │   └── DashboardController.java (or in separate dashboard package)
  ├── domain/
  │   ├── Invoice.java (from Story 2.1)
  │   ├── InvoiceRepository.java (from Story 2.1)
  │   └── exceptions/
  │       └── InvoiceNotFoundException.java (from Story 2.2)
  └── infrastructure/
      ├── JpaInvoiceRepository.java (from Story 2.1, may add custom methods)
      └── InvoiceRepositoryCustom.java (if needed for complex queries)
```

**Query Handler Responsibilities:**
- Accept query objects (records)
- Load data from repositories (read-only operations)
- Join data from multiple aggregates if needed (Invoice + Customer)
- Calculate computed/derived fields (daysOverdue, stats)
- Convert domain entities to response DTOs
- Return DTOs optimized for UI consumption
- No modifications to domain entities (read-only)
- No transactions needed (queries don't write)

**Controller Responsibilities:**
- Map HTTP requests to query objects
- Validate query parameters (optional filters, pagination)
- Call appropriate query handler
- Map responses to HTTP status codes and bodies
- Handle exceptions and return proper HTTP errors
- Add security, CORS, and other cross-cutting concerns
- Document endpoints with Swagger annotations

**CQRS Separation:**
- Queries are completely separate from commands
- Query handlers may read from multiple aggregates (join Invoice + Customer)
- Query DTOs can be denormalized for UI optimization
- No business logic or state changes in queries
- Commands use InvoiceCommandController, queries use InvoiceQueryController
- Potential for future optimization: separate read database or cache

### File Locations

**Backend Files** [Source: architecture.md#Unified Project Structure]:
```
backend/src/main/java/com/invoiceme/features/invoice/
  ├── queries/
  │   ├── GetInvoiceByIdQuery.java
  │   ├── GetInvoiceByIdQueryHandler.java
  │   ├── ListInvoicesQuery.java
  │   ├── ListInvoicesQueryHandler.java
  │   ├── GetDashboardStatsQuery.java
  │   ├── GetDashboardStatsQueryHandler.java
  │   └── dto/
  │       ├── InvoiceListItemDTO.java
  │       ├── DashboardStatsDTO.java
  │       └── PagedResult.java
  ├── api/
  │   ├── InvoiceQueryController.java
  │   └── DashboardController.java
  └── infrastructure/
      ├── InvoiceRepositoryCustom.java (interface)
      └── InvoiceRepositoryCustomImpl.java (implementation)

backend/src/main/java/com/invoiceme/common/dto/
  └── PagedResult.java (if shared across features)

backend/src/test/java/com/invoiceme/features/invoice/
  ├── queries/
  │   ├── GetInvoiceByIdQueryHandlerTest.java (unit tests)
  │   ├── ListInvoicesQueryHandlerTest.java (unit tests)
  │   └── GetDashboardStatsQueryHandlerTest.java (unit tests)
  ├── api/
  │   └── InvoiceQueryIntegrationTest.java (integration tests)
  └── infrastructure/
      └── InvoiceRepositoryCustomTest.java (repository tests)
```

### Testing Requirements

**Testing Strategy** [Source: architecture.md#Tech Stack]:
- JUnit 5 for all tests
- Mockito for mocking dependencies in unit tests
- Spring Boot Test (@SpringBootTest, @WebMvcTest) for integration tests
- MockMvc for testing REST endpoints
- AssertJ for fluent assertions
- @DataJpaTest for repository tests

**Test Coverage Requirements** [Source: prd.md#Technical Assumptions - Testing Requirements]:
- Unit tests for all query handlers
- Integration tests for complete query flows via REST API
- Test filtering, pagination, and sorting
- Test calculated fields are correct
- Test performance with larger datasets (1000+ records)
- Minimum 80% code coverage

**Unit Test Structure** (Query Handlers):
```java
@ExtendWith(MockitoExtension.class)
class GetInvoiceByIdQueryHandlerTest {
    @Mock
    private InvoiceRepository invoiceRepository;

    @Mock
    private CustomerRepository customerRepository;

    @InjectMocks
    private GetInvoiceByIdQueryHandler handler;

    @Test
    void shouldGetInvoiceWithAllDetails() {
        // Arrange: create test invoice and customer
        Invoice invoice = createTestInvoice();
        Customer customer = createTestCustomer();
        when(invoiceRepository.findById(any())).thenReturn(Optional.of(invoice));
        when(customerRepository.findById(any())).thenReturn(Optional.of(customer));

        // Act
        GetInvoiceByIdQuery query = new GetInvoiceByIdQuery(invoice.getId());
        InvoiceResponseDTO result = handler.handle(query);

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.id()).isEqualTo(invoice.getId());
        assertThat(result.customerName()).isEqualTo(customer.getName());
        assertThat(result.subtotal()).isEqualTo(invoice.getSubtotal());
        assertThat(result.lineItems()).hasSize(invoice.getLineItems().size());
        // Verify all calculated fields are present
    }

    @Test
    void shouldThrowExceptionWhenInvoiceNotFound() {
        // Arrange
        when(invoiceRepository.findById(any())).thenReturn(Optional.empty());

        // Act & Assert
        GetInvoiceByIdQuery query = new GetInvoiceByIdQuery(UUID.randomUUID());
        assertThatThrownBy(() -> handler.handle(query))
            .isInstanceOf(InvoiceNotFoundException.class);
    }

    @Test
    void shouldCalculateDaysOverdueForOverdueInvoice() {
        // Arrange: invoice with due date in past, status = Sent
        Invoice invoice = createOverdueInvoice();
        Customer customer = createTestCustomer();
        when(invoiceRepository.findById(any())).thenReturn(Optional.of(invoice));
        when(customerRepository.findById(any())).thenReturn(Optional.of(customer));

        // Act
        InvoiceResponseDTO result = handler.handle(new GetInvoiceByIdQuery(invoice.getId()));

        // Assert
        assertThat(result.daysOverdue()).isNotNull();
        assertThat(result.daysOverdue()).isGreaterThan(0);
    }
}
```

**Integration Test Structure** (Controller + Full Stack):
```java
@SpringBootTest
@AutoConfigureMockMvc
class InvoiceQueryIntegrationTest {
    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private InvoiceRepository invoiceRepository;

    @Autowired
    private CustomerRepository customerRepository;

    @BeforeEach
    void setUp() {
        // Create test data: customers and invoices
    }

    @Test
    void shouldGetInvoiceById() throws Exception {
        // Arrange: create invoice in database
        Invoice invoice = createAndSaveInvoice();

        // Act & Assert
        mockMvc.perform(get("/api/invoices/{id}", invoice.getId())
                .header("Authorization", "Bearer " + getTestToken()))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.id").value(invoice.getId().toString()))
            .andExpect(jsonPath("$.invoiceNumber").value(invoice.getInvoiceNumber()))
            .andExpect(jsonPath("$.customerName").exists())
            .andExpect(jsonPath("$.subtotal").exists())
            .andExpect(jsonPath("$.lineItems").isArray());
    }

    @Test
    void shouldListInvoicesWithFilters() throws Exception {
        // Arrange: create multiple invoices with different statuses
        Customer customer = createAndSaveCustomer();
        createAndSaveInvoice(customer, InvoiceStatus.Draft);
        createAndSaveInvoice(customer, InvoiceStatus.Sent);

        // Act & Assert: filter by status
        mockMvc.perform(get("/api/invoices")
                .param("status", "Sent")
                .header("Authorization", "Bearer " + getTestToken()))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.content").isArray())
            .andExpect(jsonPath("$.content[*].status").value(everyItem(is("Sent"))))
            .andExpect(jsonPath("$.totalElements").exists());
    }

    @Test
    void shouldPaginateInvoiceList() throws Exception {
        // Arrange: create 25 invoices
        for (int i = 0; i < 25; i++) {
            createAndSaveInvoice();
        }

        // Act & Assert: request page 0 with size 10
        mockMvc.perform(get("/api/invoices")
                .param("page", "0")
                .param("size", "10")
                .header("Authorization", "Bearer " + getTestToken()))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.content").isArray())
            .andExpect(jsonPath("$.content.length()").value(10))
            .andExpect(jsonPath("$.page").value(0))
            .andExpect(jsonPath("$.size").value(10))
            .andExpect(jsonPath("$.totalElements").value(25))
            .andExpect(jsonPath("$.totalPages").value(3));
    }

    @Test
    void shouldGetDashboardStats() throws Exception {
        // Arrange: create invoices with different statuses
        createAndSaveInvoice(InvoiceStatus.Draft);
        createAndSaveInvoice(InvoiceStatus.Sent);
        createAndSaveInvoice(InvoiceStatus.Paid);

        // Act & Assert
        mockMvc.perform(get("/api/dashboard/stats")
                .header("Authorization", "Bearer " + getTestToken()))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.totalInvoices").value(3))
            .andExpect(jsonPath("$.draftInvoices").value(1))
            .andExpect(jsonPath("$.sentInvoices").value(1))
            .andExpect(jsonPath("$.paidInvoices").value(1))
            .andExpect(jsonPath("$.totalRevenue").exists())
            .andExpect(jsonPath("$.outstandingAmount").exists());
    }
}
```

### Technical Constraints

**Dependencies** [Source: architecture.md#Tech Stack]:
- Spring Boot 3.2.x
- Spring Web (for REST controllers)
- Spring Data JPA (for repositories)
- Spring Security (for JWT auth on endpoints)
- Java 17+
- PostgreSQL 15 (with proper indexes)
- AssertJ (for test assertions)

**CQRS Pattern** [Source: architecture.md#Architectural Patterns]:
- Queries are in queries/ package, separate from commands/
- Query handlers contain read logic only
- Query models (DTOs) can be denormalized and optimized for reads
- Queries can join multiple aggregates (Invoice + Customer)
- No state changes or business logic in queries
- This story focuses on READ operations only (no commands)

**Performance Optimization** [Source: PRD Epic 2 Story 2.3 AC 8, prd.md#Non Functional Requirements]:
- NFR1: API response times must be under 200ms for CRUD operations
- AC8: Invoice list query under 100ms for 1000 records
- Use database indexes on frequently queried fields (customer_id, status, dates)
- Use JOIN FETCH to avoid N+1 queries when loading customer with invoice
- Use Spring Data JPA projections for lightweight list DTOs
- Consider native SQL queries if JPQL performance is insufficient
- Test query performance with realistic dataset sizes (1000+ records)
- Pagination is mandatory for list queries to prevent memory issues

**Query Optimization Techniques:**
1. **Indexes**: Ensure indexes exist on customer_id, status, issue_date, due_date
2. **JOIN FETCH**: `SELECT i FROM Invoice i JOIN FETCH i.customer WHERE i.id = :id`
3. **Projections**: Use interface-based or DTO projections for list queries
4. **Pagination**: Always use PageRequest for list queries to limit results
5. **Native Queries**: Use @Query with native SQL if complex aggregations needed
6. **Caching**: Consider caching for dashboard stats (future optimization)

**Calculated Fields:**
- **daysOverdue**: Calculated in handler: `ChronoUnit.DAYS.between(dueDate, LocalDate.now())`
- Only set if status != Paid and today > dueDate
- **Subtotal, totalDiscount, totalTax, totalAmount, balance**: Read from Invoice aggregate (already calculated on write)
- **LineItem calculations**: Read from LineItem value object (subtotal, discountAmount, taxableAmount, taxAmount, total)

**Repository Pattern Extensions:**
If complex queries are needed beyond standard Spring Data JPA:
1. Create InvoiceRepositoryCustom interface with custom query methods
2. Implement InvoiceRepositoryCustomImpl using EntityManager or JdbcTemplate
3. Example: `findInvoicesWithFilters(customerId, status, dateRange, pageable)`
4. Use Criteria API for dynamic filtering or native SQL for performance

**Error Handling:**
- InvoiceNotFoundException -> 404 Not Found
- Invalid query parameters -> 400 Bad Request
- Use @ExceptionHandler in controller or global @ControllerAdvice
- Return standard error response format from architecture

### Coding Standards

**Critical Rules** [Source: architecture.md#Coding Standards]:
- CQRS Separation: Queries in queries/, commands in commands/
- DTO Pattern: Never expose domain entities directly through APIs
- Read-Only Operations: Queries must not modify state
- Query Optimization: Use indexes, JOIN FETCH, projections for performance
- Consistent Naming: Queries end with "Query", Handlers with "Handler", DTOs with "DTO"

**Naming Conventions** [Source: architecture.md#Coding Standards]:
- Classes: PascalCase (GetInvoiceByIdQueryHandler)
- Methods: camelCase (handle, findInvoices)
- Constants: SCREAMING_SNAKE_CASE
- Packages: lowercase (queries, dto, api)

**Java Code Style**:
- Use Java records for immutable DTOs and queries
- Use constructor injection for dependencies (no @Autowired on fields)
- Keep query handlers focused (single responsibility)
- Add JavaDoc comments for public APIs
- Use meaningful variable names

**Spring Security Integration** [Source: architecture.md#Tech Stack]:
- All invoice query endpoints require authentication
- Use SecurityFilterChain to protect endpoints
- Invoice query endpoints (/api/invoices/**) require Bearer token
- Dashboard endpoints (/api/dashboard/**) require Bearer token

**Transaction Management**:
- Queries typically don't need @Transactional (read-only)
- If @Transactional is used, mark as readOnly=true for optimization
- Example: `@Transactional(readOnly = true)`
- This allows database optimizations for read-only operations

**Mapper Pattern**:
Use InvoiceMapper utility class to convert entities to DTOs:
```java
public class InvoiceMapper {
    public static InvoiceResponseDTO toInvoiceResponseDTO(Invoice invoice, Customer customer) {
        return new InvoiceResponseDTO(
            invoice.getId(),
            invoice.getInvoiceNumber(),
            customer.getId(),
            customer.getName(),
            customer.getEmail(),
            invoice.getIssueDate(),
            invoice.getDueDate(),
            invoice.getStatus(),
            invoice.getPaymentTerms(),
            invoice.getSubtotal(),
            invoice.getTotalDiscount(),
            invoice.getTotalTax(),
            invoice.getTotalAmount(),
            invoice.getBalance(),
            invoice.getLineItems().stream()
                .map(InvoiceMapper::toLineItemResponseDTO)
                .toList(),
            invoice.getNotes(),
            invoice.getVersion(),
            invoice.getCreatedAt(),
            invoice.getUpdatedAt(),
            calculateDaysOverdue(invoice)
        );
    }

    public static InvoiceListItemDTO toInvoiceListItemDTO(Invoice invoice, String customerName) {
        return new InvoiceListItemDTO(
            invoice.getId(),
            invoice.getInvoiceNumber(),
            invoice.getCustomerId(),
            customerName,
            invoice.getIssueDate(),
            invoice.getDueDate(),
            invoice.getStatus(),
            invoice.getTotalAmount(),
            invoice.getBalance(),
            invoice.getVersion(),
            calculateDaysOverdue(invoice)
        );
    }

    public static LineItemResponseDTO toLineItemResponseDTO(LineItem lineItem) {
        return new LineItemResponseDTO(
            lineItem.getId(),
            lineItem.getDescription(),
            lineItem.getQuantity(),
            lineItem.getUnitPrice(),
            lineItem.getDiscountPercent(),
            lineItem.getTaxRate(),
            lineItem.getSubtotal(),
            lineItem.getDiscountAmount(),
            lineItem.getTaxableAmount(),
            lineItem.getTaxAmount(),
            lineItem.getTotal()
        );
    }

    private static Integer calculateDaysOverdue(Invoice invoice) {
        if (invoice.getStatus() == InvoiceStatus.Paid) {
            return null;
        }
        LocalDate today = LocalDate.now();
        if (today.isAfter(invoice.getDueDate())) {
            return (int) ChronoUnit.DAYS.between(invoice.getDueDate(), today);
        }
        return null;
    }
}
```

## Testing
- Unit tests required for all query handlers (GetInvoiceByIdQueryHandler, ListInvoicesQueryHandler, GetDashboardStatsQueryHandler)
- Mock all dependencies (repositories) in unit tests
- Integration tests required for complete query flows via REST API
- Test all filtering scenarios (customer, status, date range)
- Test pagination and sorting work correctly
- Test calculated fields are accurate (daysOverdue, stats)
- Test performance with 1000+ invoice records (list query under 100ms)
- Test 404 for non-existent invoices
- Use MockMvc for API testing with JSON responses
- Minimum 80% code coverage for new code
- Tests should follow AAA pattern (Arrange, Act, Assert)
- Use AssertJ for fluent assertions: assertThat(result).isNotNull().hasFieldOrPropertyWithValue("status", InvoiceStatus.Sent)

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-11-08 | v1.0 | Initial story creation from PRD Epic 2 Story 2.3 | Claude (Story Agent) |

## Dev Agent Record

### Agent Model Used
Not yet implemented

### Debug Log References
None yet - will be populated during implementation

### Completion Notes List
None yet - will be populated during implementation

### File List
None yet - will be populated during implementation

## QA Results
Not yet reviewed
