# Story 2.2: Invoice Commands & State Transitions

## Status
Draft

## Story
**As a** developer,
**I want** to implement Invoice commands with proper state management,
**so that** invoices follow the correct lifecycle workflow.

## Acceptance Criteria
1. CreateInvoiceCommand creates invoice in Draft status with line items
2. UpdateInvoiceCommand allows modifications only in Draft status
3. SendInvoiceCommand transitions from Draft to Sent with validation
4. Command handlers enforce business rules and state transitions
5. REST endpoints: POST /api/invoices, PUT /api/invoices/{id}, POST /api/invoices/{id}/send
6. Optimistic locking to prevent concurrent modifications
7. Command validation ensures minimum one line item before sending
8. Integration tests for all state transitions and edge cases

## Tasks / Subtasks
- [ ] Create CreateInvoiceCommand and handler (AC: 1, 4, 7)
  - [ ] Create CreateInvoiceCommand record in commands/ package
  - [ ] Add fields: customerId, issueDate, dueDate, paymentTerms, lineItems[], notes
  - [ ] Create CreateInvoiceDTO with validation annotations
  - [ ] Create CreateInvoiceCommandHandler class
  - [ ] Validate customerId exists (call CustomerRepository or throw exception)
  - [ ] Validate lineItems is not empty (at least one line item required)
  - [ ] Validate issueDate and dueDate (dueDate >= issueDate)
  - [ ] Generate invoice number using InvoiceNumberGenerator service
  - [ ] Create Invoice aggregate in Draft status using Invoice.create()
  - [ ] Add all line items to invoice aggregate
  - [ ] Save invoice using InvoiceRepository
  - [ ] Return InvoiceResponseDTO with created invoice details
  - [ ] Publish InvoiceCreated domain event
  - [ ] Unit tests for CreateInvoiceCommandHandler
  - [ ] Test validation: empty line items should throw exception
  - [ ] Test validation: invalid dates should throw exception
  - [ ] Test validation: non-existent customer should throw exception

- [ ] Create UpdateInvoiceCommand and handler (AC: 2, 4, 6)
  - [ ] Create UpdateInvoiceCommand record in commands/
  - [ ] Add fields: invoiceId, customerId, issueDate, dueDate, paymentTerms, lineItems[], notes
  - [ ] Create UpdateInvoiceDTO with validation annotations
  - [ ] Create UpdateInvoiceCommandHandler class
  - [ ] Load existing invoice by ID (throw exception if not found)
  - [ ] Validate invoice status is Draft (throw exception if Sent or Paid)
  - [ ] Validate optimistic lock version (prevent concurrent modifications)
  - [ ] Update invoice basic fields (dates, terms, notes)
  - [ ] Clear existing line items and add new ones using aggregate methods
  - [ ] Invoice aggregate will recalculate totals automatically
  - [ ] Save updated invoice
  - [ ] Return InvoiceResponseDTO
  - [ ] Unit tests for UpdateInvoiceCommandHandler
  - [ ] Test validation: updating Sent invoice should throw exception
  - [ ] Test validation: updating Paid invoice should throw exception
  - [ ] Test optimistic locking with stale version
  - [ ] Test successful update of Draft invoice

- [ ] Create SendInvoiceCommand and handler (AC: 3, 4, 7)
  - [ ] Create SendInvoiceCommand record in commands/
  - [ ] Add field: invoiceId
  - [ ] Create SendInvoiceCommandHandler class
  - [ ] Load invoice by ID (throw exception if not found)
  - [ ] Validate invoice is in Draft status (cannot send already Sent/Paid)
  - [ ] Call invoice.markAsSent() which validates line items exist
  - [ ] Save updated invoice with new status
  - [ ] Return InvoiceResponseDTO with updated status
  - [ ] Publish InvoiceStatusChanged event (via aggregate)
  - [ ] Unit tests for SendInvoiceCommandHandler
  - [ ] Test validation: sending invoice without line items should throw exception
  - [ ] Test validation: sending already Sent invoice should throw exception
  - [ ] Test validation: sending Paid invoice should throw exception
  - [ ] Test successful send transitions Draft -> Sent

- [ ] Create Invoice DTOs for commands (AC: 1, 2, 3)
  - [ ] Create CreateInvoiceDTO record with validation
  - [ ] Add @NotNull, @NotBlank, @NotEmpty annotations
  - [ ] Add @Valid for nested LineItemDTO list
  - [ ] Create UpdateInvoiceDTO with same structure as CreateInvoiceDTO
  - [ ] Add version field for optimistic locking
  - [ ] Create LineItemDTO record for command inputs
  - [ ] Add fields: description, quantity, unitPrice, discountPercent, taxRate
  - [ ] Add validation: @Positive for quantity, @PositiveOrZero for unitPrice
  - [ ] Add @Min/@Max for discountPercent (0-1) and taxRate (>=0)
  - [ ] Create InvoiceResponseDTO for query responses
  - [ ] Include all invoice fields plus customer details
  - [ ] Include calculated fields (subtotal, totalDiscount, totalTax, totalAmount, balance)
  - [ ] Add mapper methods: toInvoiceResponseDTO(Invoice, Customer)
  - [ ] Add mapper methods: toLineItemDomain(LineItemDTO)
  - [ ] Add mapper methods: toLineItemDTO(LineItem)

- [ ] Implement InvoiceCommandController (AC: 5)
  - [ ] Create InvoiceCommandController class in api/
  - [ ] Annotate with @RestController and @RequestMapping("/api/invoices")
  - [ ] Add @Validated for method-level validation
  - [ ] Inject command handlers (CreateInvoiceCommandHandler, UpdateInvoiceCommandHandler, SendInvoiceCommandHandler)
  - [ ] Implement POST /api/invoices endpoint
  - [ ] Accept @Valid @RequestBody CreateInvoiceDTO
  - [ ] Call CreateInvoiceCommandHandler
  - [ ] Return 201 Created with InvoiceResponseDTO and Location header
  - [ ] Implement PUT /api/invoices/{id} endpoint
  - [ ] Accept @PathVariable UUID id and @Valid @RequestBody UpdateInvoiceDTO
  - [ ] Call UpdateInvoiceCommandHandler
  - [ ] Return 200 OK with InvoiceResponseDTO
  - [ ] Implement POST /api/invoices/{id}/send endpoint
  - [ ] Accept @PathVariable UUID id
  - [ ] Call SendInvoiceCommandHandler
  - [ ] Return 200 OK with updated InvoiceResponseDTO
  - [ ] Add proper exception handling (@ExceptionHandler or global)
  - [ ] Add Swagger/OpenAPI annotations for documentation

- [ ] Implement optimistic locking (AC: 6)
  - [ ] Add @Version field to Invoice entity (Long version)
  - [ ] Add version field to UpdateInvoiceDTO
  - [ ] In UpdateInvoiceCommandHandler, check version matches
  - [ ] If version mismatch, throw OptimisticLockException
  - [ ] JPA will automatically increment version on save
  - [ ] Include version in InvoiceResponseDTO
  - [ ] Unit tests for optimistic locking scenarios
  - [ ] Test concurrent updates to same invoice (expect exception)
  - [ ] Integration test with JPA for version management

- [ ] Create domain exceptions for commands
  - [ ] Create InvoiceNotFoundException in domain/exceptions/
  - [ ] Create InvoiceValidationException for business rule violations
  - [ ] Create CustomerNotFoundException (or reuse from Customer domain)
  - [ ] Ensure exceptions have meaningful messages
  - [ ] Add exception to HTTP status mapping in exception handler
  - [ ] 404 for NotFound exceptions
  - [ ] 400 for Validation exceptions
  - [ ] 409 for OptimisticLock exceptions

- [ ] Write comprehensive integration tests (AC: 8)
  - [ ] Create InvoiceCommandIntegrationTest class
  - [ ] Use @SpringBootTest or @WebMvcTest for controller tests
  - [ ] Test complete flow: Create invoice in Draft -> Update -> Send
  - [ ] Test creating invoice with valid data returns 201
  - [ ] Test creating invoice with empty line items returns 400
  - [ ] Test creating invoice with invalid dates returns 400
  - [ ] Test creating invoice with non-existent customer returns 404
  - [ ] Test updating Draft invoice succeeds
  - [ ] Test updating Sent invoice returns 400/409
  - [ ] Test updating with stale version returns 409
  - [ ] Test sending Draft invoice with line items succeeds
  - [ ] Test sending Draft invoice without line items returns 400
  - [ ] Test sending already Sent invoice returns 400/409
  - [ ] Test invoice number is unique and sequential
  - [ ] Test invoice totals are calculated correctly
  - [ ] Test state transitions publish correct domain events
  - [ ] Use MockMvc for API endpoint testing
  - [ ] Use AssertJ for fluent assertions

- [ ] Add command handler unit tests
  - [ ] Unit test CreateInvoiceCommandHandler with mocked repository
  - [ ] Mock CustomerRepository to return existing customer
  - [ ] Mock InvoiceNumberGenerator to return predictable numbers
  - [ ] Mock InvoiceRepository save operation
  - [ ] Verify invoice is created with correct status (Draft)
  - [ ] Verify line items are added to invoice
  - [ ] Verify totals are calculated (call aggregate methods)
  - [ ] Unit test UpdateInvoiceCommandHandler with mocked repository
  - [ ] Mock repository to return existing Draft invoice
  - [ ] Verify status validation (Sent/Paid invoices throw exception)
  - [ ] Verify line items are replaced correctly
  - [ ] Unit test SendInvoiceCommandHandler with mocked repository
  - [ ] Mock repository to return Draft invoice with line items
  - [ ] Verify markAsSent() is called on aggregate
  - [ ] Verify status changes to Sent
  - [ ] Test all validation edge cases in each handler

## Dev Notes

### Previous Story Insights
**Story 2.1 Completion:**
Story 2.1 implemented the Invoice domain model with:
- Invoice aggregate root with all business logic
- LineItem value object as immutable record with calculations
- InvoiceStatus enum (Draft, Sent, Paid)
- Domain methods: addLineItem(), removeLineItem(), updateLineItem(), calculateTotals()
- State transition methods: markAsSent(), markAsPaid(), applyPayment()
- Domain events: InvoiceCreated, InvoiceStatusChanged, LineItemAdded, LineItemRemoved
- InvoiceRepository interface in domain/
- JpaInvoiceRepository implementation with JSONB for line items
- InvoiceNumberGenerator service for sequential invoice numbers (INV-YYYY-NNNN)
- Database migration with invoices table, JSONB line_items column, indexes
- Comprehensive unit tests for domain logic and invariants

**Key Technical Patterns Established:**
From Epic 1 Customer domain:
- Commands placed in features/{feature}/commands/ package
- Command handlers implement business logic and call domain methods
- DTOs validate input and convert to domain objects
- Controllers delegate to command handlers
- Repository pattern: inject repository interfaces, not implementations
- Domain events published from aggregate roots
- Exceptions: domain exceptions in domain/exceptions/, map to HTTP status in controller
- Use Java records for immutable DTOs and commands
- Use @Valid and Jakarta Validation annotations for input validation
- Service layer (command handlers) contains application logic, domain contains business logic

### Data Models

**CreateInvoiceCommand** [Derived from PRD Epic 2 Story 2.2 AC 1]:
```java
public record CreateInvoiceCommand(
    UUID customerId,
    LocalDate issueDate,
    LocalDate dueDate,
    String paymentTerms,
    List<LineItemDTO> lineItems,
    String notes
) {}
```

**UpdateInvoiceCommand** [Derived from PRD Epic 2 Story 2.2 AC 2]:
```java
public record UpdateInvoiceCommand(
    UUID invoiceId,
    UUID customerId,
    LocalDate issueDate,
    LocalDate dueDate,
    String paymentTerms,
    List<LineItemDTO> lineItems,
    String notes,
    Long version  // For optimistic locking
) {}
```

**SendInvoiceCommand** [Derived from PRD Epic 2 Story 2.2 AC 3]:
```java
public record SendInvoiceCommand(
    UUID invoiceId
) {}
```

**CreateInvoiceDTO** [Derived from architecture.md#Data Models]:
```java
public record CreateInvoiceDTO(
    @NotNull(message = "Customer ID is required")
    UUID customerId,

    @NotNull(message = "Issue date is required")
    LocalDate issueDate,

    LocalDate dueDate,  // Optional, can default to issueDate + payment terms

    @NotBlank(message = "Payment terms are required")
    String paymentTerms,  // e.g., "Net 30", "Due on receipt"

    @NotEmpty(message = "At least one line item is required")
    @Valid
    List<LineItemDTO> lineItems,

    String notes  // Optional
) {}
```

**UpdateInvoiceDTO** [Derived from architecture.md#Data Models]:
```java
public record UpdateInvoiceDTO(
    @NotNull
    UUID customerId,

    @NotNull
    LocalDate issueDate,

    LocalDate dueDate,

    @NotBlank
    String paymentTerms,

    @NotEmpty
    @Valid
    List<LineItemDTO> lineItems,

    String notes,

    @NotNull(message = "Version is required for optimistic locking")
    Long version
) {}
```

**LineItemDTO** [Derived from architecture.md#Data Models]:
```java
public record LineItemDTO(
    @NotBlank(message = "Description is required")
    String description,

    @Positive(message = "Quantity must be positive")
    int quantity,

    @PositiveOrZero(message = "Unit price cannot be negative")
    BigDecimal unitPrice,

    @DecimalMin(value = "0.0", message = "Discount percent must be >= 0")
    @DecimalMax(value = "1.0", message = "Discount percent must be <= 1")
    BigDecimal discountPercent,  // Default to 0 if not provided

    @DecimalMin(value = "0.0", message = "Tax rate must be >= 0")
    BigDecimal taxRate  // Default to 0 if not provided
) {
    // Provide defaults for optional fields
    public LineItemDTO {
        if (discountPercent == null) discountPercent = BigDecimal.ZERO;
        if (taxRate == null) taxRate = BigDecimal.ZERO;
    }
}
```

**InvoiceResponseDTO** [Source: architecture.md#API Specification]:
```java
public record InvoiceResponseDTO(
    UUID id,
    String invoiceNumber,
    UUID customerId,
    String customerName,      // Joined from Customer
    String customerEmail,     // Joined from Customer
    LocalDate issueDate,
    LocalDate dueDate,
    InvoiceStatus status,
    String paymentTerms,

    // Calculated totals
    BigDecimal subtotal,
    BigDecimal totalDiscount,
    BigDecimal totalTax,
    BigDecimal totalAmount,
    BigDecimal balance,

    List<LineItemResponseDTO> lineItems,
    String notes,
    Long version,  // For optimistic locking
    Instant createdAt,
    Instant updatedAt,

    Integer daysOverdue  // Calculated: if status != Paid and today > dueDate
) {}

public record LineItemResponseDTO(
    String id,
    String description,
    int quantity,
    BigDecimal unitPrice,
    BigDecimal discountPercent,
    BigDecimal taxRate,

    // Calculated fields
    BigDecimal subtotal,
    BigDecimal discountAmount,
    BigDecimal taxableAmount,
    BigDecimal taxAmount,
    BigDecimal total
) {}
```

### API Specifications

**Invoice Command Endpoints** [Source: architecture.md#REST API Specification]:

**POST /api/invoices** (Create Invoice Command)
- Request: CreateInvoiceDTO (JSON)
- Response: 201 Created with InvoiceResponseDTO
- Headers: Location: /api/invoices/{id}
- Auth: Bearer token required
- Validations:
  - Customer exists
  - At least one line item
  - Issue date and due date valid
  - Line items have positive quantities and prices
- Errors:
  - 400 Bad Request if validation fails
  - 404 Not Found if customer doesn't exist
  - 401 Unauthorized if no/invalid token

**PUT /api/invoices/{id}** (Update Invoice Command)
- Path: id (UUID)
- Request: UpdateInvoiceDTO (JSON)
- Response: 200 OK with InvoiceResponseDTO
- Auth: Bearer token required
- Validations:
  - Invoice exists
  - Invoice status is Draft
  - Version matches (optimistic locking)
  - At least one line item
- Errors:
  - 400 Bad Request if validation fails
  - 404 Not Found if invoice doesn't exist
  - 409 Conflict if invoice status is not Draft or version mismatch
  - 401 Unauthorized if no/invalid token

**POST /api/invoices/{id}/send** (Send Invoice Command)
- Path: id (UUID)
- Request: Empty body
- Response: 200 OK with InvoiceResponseDTO (status = Sent)
- Auth: Bearer token required
- Validations:
  - Invoice exists
  - Invoice status is Draft
  - Invoice has at least one line item
- Errors:
  - 400 Bad Request if invoice has no line items
  - 404 Not Found if invoice doesn't exist
  - 409 Conflict if invoice is not in Draft status
  - 401 Unauthorized if no/invalid token

[Source: architecture.md#API Specification - REST API Specification]

### Component Specifications

**Invoice Command Module Structure** [Source: architecture.md#Components - Invoice Vertical Slice]:
```
backend/src/main/java/com/invoiceme/features/invoice/
  ├── commands/
  │   ├── CreateInvoiceCommand.java (record)
  │   ├── CreateInvoiceCommandHandler.java
  │   ├── UpdateInvoiceCommand.java (record)
  │   ├── UpdateInvoiceCommandHandler.java
  │   ├── SendInvoiceCommand.java (record)
  │   ├── SendInvoiceCommandHandler.java
  │   └── dto/
  │       ├── CreateInvoiceDTO.java
  │       ├── UpdateInvoiceDTO.java
  │       ├── LineItemDTO.java
  │       ├── InvoiceResponseDTO.java
  │       ├── LineItemResponseDTO.java
  │       └── InvoiceMapper.java (utility class for DTO conversions)
  ├── api/
  │   └── InvoiceCommandController.java
  ├── domain/
  │   ├── Invoice.java (from Story 2.1)
  │   ├── LineItem.java (from Story 2.1)
  │   ├── InvoiceStatus.java (from Story 2.1)
  │   ├── InvoiceRepository.java (from Story 2.1)
  │   ├── InvoiceNumberGenerator.java (from Story 2.1)
  │   └── exceptions/
  │       ├── InvoiceNotFoundException.java
  │       ├── InvoiceValidationException.java
  │       ├── InvoiceImmutableException.java (from Story 2.1)
  │       └── InvalidInvoiceStateException.java (from Story 2.1)
  └── infrastructure/
      ├── JpaInvoiceRepository.java (from Story 2.1)
      └── SequentialInvoiceNumberGenerator.java (from Story 2.1)
```

**Command Handler Responsibilities:**
- Accept command objects (records)
- Validate command data and business rules
- Load/create domain aggregates
- Call domain methods to perform operations
- Save aggregates via repository
- Return DTOs for API responses
- Handle domain exceptions and convert to application exceptions
- No direct HTTP concerns (that's the controller's job)

**Controller Responsibilities:**
- Map HTTP requests to DTOs
- Validate DTOs using @Valid
- Call appropriate command handler
- Map responses to HTTP status codes and bodies
- Handle exceptions and return proper HTTP errors
- Add security, CORS, and other cross-cutting concerns
- Document endpoints with Swagger annotations

### File Locations

**Backend Files** [Source: architecture.md#Unified Project Structure]:
```
backend/src/main/java/com/invoiceme/features/invoice/
  ├── commands/
  │   ├── CreateInvoiceCommand.java
  │   ├── CreateInvoiceCommandHandler.java
  │   ├── UpdateInvoiceCommand.java
  │   ├── UpdateInvoiceCommandHandler.java
  │   ├── SendInvoiceCommand.java
  │   ├── SendInvoiceCommandHandler.java
  │   └── dto/
  │       ├── CreateInvoiceDTO.java
  │       ├── UpdateInvoiceDTO.java
  │       ├── LineItemDTO.java
  │       ├── InvoiceResponseDTO.java
  │       ├── LineItemResponseDTO.java
  │       └── InvoiceMapper.java
  ├── api/
  │   └── InvoiceCommandController.java
  └── domain/exceptions/
      ├── InvoiceNotFoundException.java
      └── InvoiceValidationException.java

backend/src/test/java/com/invoiceme/features/invoice/
  ├── commands/
  │   ├── CreateInvoiceCommandHandlerTest.java (unit tests)
  │   ├── UpdateInvoiceCommandHandlerTest.java (unit tests)
  │   └── SendInvoiceCommandHandlerTest.java (unit tests)
  └── api/
      └── InvoiceCommandIntegrationTest.java (integration tests)
```

### Testing Requirements

**Testing Strategy** [Source: architecture.md#Tech Stack]:
- JUnit 5 for all tests
- Mockito for mocking dependencies in unit tests
- Spring Boot Test (@SpringBootTest, @WebMvcTest) for integration tests
- MockMvc for testing REST endpoints
- AssertJ for fluent assertions
- Use @DataJpaTest for repository tests (already done in Story 2.1)

**Test Coverage Requirements** [Source: prd.md#Technical Assumptions - Testing Requirements]:
- Unit tests for all command handlers
- Integration tests for complete command flows
- Test validation rules and business invariants
- Test state transitions (Draft -> Sent)
- Test optimistic locking scenarios
- Test error conditions and exception handling
- Minimum 80% code coverage

**Unit Test Structure** (Command Handlers):
```java
@ExtendWith(MockitoExtension.class)
class CreateInvoiceCommandHandlerTest {
    @Mock
    private InvoiceRepository invoiceRepository;

    @Mock
    private CustomerRepository customerRepository;

    @Mock
    private InvoiceNumberGenerator invoiceNumberGenerator;

    @InjectMocks
    private CreateInvoiceCommandHandler handler;

    @Test
    void shouldCreateInvoiceSuccessfully() {
        // Arrange: create command, mock dependencies
        // Act: call handler.handle(command)
        // Assert: verify invoice created with Draft status, line items added, totals calculated
    }

    @Test
    void shouldThrowExceptionWhenCustomerNotFound() {
        // Arrange: mock customerRepository.findById() returns empty
        // Act & Assert: assertThatThrownBy(() -> handler.handle(command))
        //   .isInstanceOf(CustomerNotFoundException.class)
    }

    @Test
    void shouldThrowExceptionWhenLineItemsEmpty() {
        // Arrange: create command with empty line items list
        // Act & Assert: verify validation exception thrown
    }
}
```

**Integration Test Structure** (Controller + Full Stack):
```java
@SpringBootTest
@AutoConfigureMockMvc
class InvoiceCommandIntegrationTest {
    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private InvoiceRepository invoiceRepository;

    @Autowired
    private CustomerRepository customerRepository;

    @Test
    void shouldCreateInvoiceViaAPI() throws Exception {
        // Arrange: create customer, prepare CreateInvoiceDTO JSON
        // Act: POST /api/invoices with DTO
        // Assert: 201 Created, invoice in database with Draft status
    }

    @Test
    void shouldNotUpdateSentInvoice() throws Exception {
        // Arrange: create invoice, send it (status = Sent)
        // Act: PUT /api/invoices/{id} with update DTO
        // Assert: 409 Conflict or 400 Bad Request
    }

    @Test
    void shouldSendDraftInvoice() throws Exception {
        // Arrange: create draft invoice with line items
        // Act: POST /api/invoices/{id}/send
        // Assert: 200 OK, invoice status = Sent, cannot edit anymore
    }
}
```

### Technical Constraints

**Dependencies** [Source: architecture.md#Tech Stack]:
- Spring Boot 3.2.x
- Spring Web (for REST controllers)
- Spring Data JPA (for repositories)
- Spring Validation (Jakarta Validation API)
- Spring Security (for JWT auth on endpoints)
- Java 17+
- Lombok (optional, for reducing boilerplate)
- AssertJ (for test assertions)

**CQRS Pattern** [Source: architecture.md#Architectural Patterns]:
- Commands are in commands/ package, separate from queries/
- Command handlers contain write logic
- Commands should not return query-optimized data (use simple DTOs)
- Query models will be in queries/ package (Story 2.3)
- This story focuses on WRITE operations only

**Optimistic Locking** [Source: PRD Epic 2 Story 2.2 AC 6]:
- Use JPA @Version annotation on Invoice entity
- Version field is Long, auto-incremented by JPA on each update
- Include version in UpdateInvoiceDTO
- In UpdateInvoiceCommandHandler, check if loaded invoice version matches DTO version
- If mismatch, throw OptimisticLockException
- Frontend should include version in update requests (from previous read)
- This prevents lost updates when multiple users edit the same invoice

**State Transition Rules** [Source: architecture.md#Data Models - Invoice]:
- Draft -> Sent: Allowed if invoice has at least one line item
- Sent -> Paid: Allowed only when balance = 0 (via payment application in Story 3)
- Sent -> Draft: NOT allowed (invoices cannot be "unsent")
- Paid -> Draft/Sent: NOT allowed (payments are final)
- Draft invoices can be edited (UpdateInvoiceCommand)
- Sent/Paid invoices cannot be edited (throw exception)

**Validation Layers** [Source: architecture.md#Coding Standards]:
1. **DTO Validation**: Use Jakarta Validation annotations (@NotNull, @NotBlank, @Positive, etc.)
2. **Command Handler Validation**: Business rule validation (customer exists, invoice in correct state)
3. **Domain Validation**: Invariants enforced in aggregate methods (line items not empty, dates valid)

**Exception Handling** [Source: architecture.md#Components - Cross-Cutting Components]:
- Domain exceptions in domain/exceptions/
- Map domain exceptions to HTTP status codes:
  - InvoiceNotFoundException -> 404 Not Found
  - InvoiceValidationException -> 400 Bad Request
  - CustomerNotFoundException -> 404 Not Found
  - InvoiceImmutableException -> 409 Conflict
  - InvalidInvoiceStateException -> 409 Conflict
  - OptimisticLockException -> 409 Conflict
- Use @ExceptionHandler in controller or global @ControllerAdvice
- Return standard error response format: `{ "message": "...", "timestamp": "...", "path": "..." }`

**Performance Considerations** [Source: prd.md#Non Functional Requirements]:
- NFR1: API response times must be under 200ms for CRUD operations
- Use single transaction for command operations
- Avoid N+1 queries (fetch customer with invoice in one query if needed)
- Line items stored as JSONB, loaded with invoice in single query
- Invoice number generation should be fast (database sequence)

### Coding Standards

**Critical Rules** [Source: architecture.md#Coding Standards]:
- CQRS Separation: Commands in commands/, queries in queries/
- DTO Pattern: Never expose domain entities directly through APIs
- Validation Layers: Validate in DTO (annotations), handler (business), domain (invariants)
- Transaction Boundaries: Use @Transactional at command handler level, not controller
- Consistent Naming: Commands end with "Command", Handlers with "Handler", DTOs with "DTO"

**Naming Conventions** [Source: architecture.md#Coding Standards]:
- Classes: PascalCase (CreateInvoiceCommandHandler)
- Methods: camelCase (handle, createInvoice)
- Constants: SCREAMING_SNAKE_CASE
- Packages: lowercase (commands, dto, api)

**Java Code Style**:
- Use Java records for immutable DTOs and commands
- Use constructor injection for dependencies (no @Autowired on fields)
- Keep command handlers focused (single responsibility)
- Use meaningful exception messages
- Add JavaDoc comments for public APIs

**Spring Security Integration** [Source: architecture.md#Tech Stack, technical-notes-auth.md]:
- All invoice endpoints require authentication
- Use @PreAuthorize or SecurityFilterChain to protect endpoints
- Auth endpoints (/api/auth/**) are public
- Invoice endpoints (/api/invoices/**) require Bearer token
- Controllers should have access to authenticated user context if needed

**Transaction Management**:
- Use @Transactional on command handler methods
- Default propagation (REQUIRED) is sufficient
- Ensure rollback on exceptions
- Keep transactions short (load, modify, save)

## Testing
- Unit tests required for all command handlers (CreateInvoiceCommandHandler, UpdateInvoiceCommandHandler, SendInvoiceCommandHandler)
- Mock all dependencies (repositories, generators) in unit tests
- Integration tests required for complete command flows via REST API
- Test all validation scenarios (empty line items, invalid dates, non-existent customer, wrong status)
- Test state transitions: Draft -> Sent (valid), Sent -> update (invalid)
- Test optimistic locking: concurrent updates should fail
- Test domain events are published correctly
- Use MockMvc for API testing with JSON requests/responses
- Minimum 80% code coverage for new code
- Tests should follow AAA pattern (Arrange, Act, Assert)
- Use AssertJ for fluent assertions: assertThat(result).isNotNull().hasFieldOrPropertyWithValue("status", InvoiceStatus.Draft)

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-11-08 | v1.0 | Initial story creation from PRD Epic 2 Story 2.2 | Claude (Story Agent) |

## Dev Agent Record

### Agent Model Used
Not yet implemented

### Debug Log References
None yet - will be populated during implementation

### Completion Notes List
None yet - will be populated during implementation

### File List
None yet - will be populated during implementation

## QA Results
Not yet reviewed
