# Story 3.3: Payment Queries & History

## Status
Draft

## Story
**As a** developer,
**I want** to implement payment queries and history tracking,
**so that** users can view payment details and transaction history.

## Acceptance Criteria
1. GetPaymentByIdQuery returns payment with invoice details
2. ListPaymentsByInvoiceQuery shows all payments for an invoice
3. PaymentHistoryQuery with date range and customer filters
4. PaymentResponseDTO includes invoice number, customer name
5. REST endpoints: GET /api/payments/{id}, GET /api/invoices/{id}/payments
6. Dashboard payment statistics (total collected, by method, by period)
7. Query includes running balance calculation per payment
8. Export-ready format for accounting reconciliation

## Tasks / Subtasks
- [ ] Create GetPaymentByIdQuery and Handler (AC: 1, 4)
  - [ ] Create GetPaymentByIdQuery.java in features/payment/queries/
  - [ ] Define as record with single field: UUID paymentId
  - [ ] Create GetPaymentByIdQueryHandler.java in features/payment/queries/
  - [ ] Annotate with @Service and @Transactional(readOnly = true)
  - [ ] Inject dependencies: PaymentRepository, InvoiceRepository
  - [ ] Implement handle(GetPaymentByIdQuery query) method
  - [ ] Fetch payment by ID using paymentRepository.findById()
  - [ ] Throw EntityNotFoundException if payment not found
  - [ ] Fetch related invoice using invoiceRepository.findById(payment.getInvoiceId())
  - [ ] Fetch customer from invoice (invoice.getCustomer() or separate query)
  - [ ] Map to PaymentResponseDTO including invoice number and customer name
  - [ ] Calculate remaining balance: invoice.getBalance()
  - [ ] Return PaymentResponseDTO with all computed fields
  - [ ] Add logging: "Retrieved payment {paymentId}"

- [ ] Create ListPaymentsByInvoiceQuery and Handler (AC: 2, 7)
  - [ ] Create ListPaymentsByInvoiceQuery.java in features/payment/queries/
  - [ ] Define as record with field: UUID invoiceId
  - [ ] Create ListPaymentsByInvoiceQueryHandler.java in features/payment/queries/
  - [ ] Annotate with @Service and @Transactional(readOnly = true)
  - [ ] Inject PaymentRepository and InvoiceRepository
  - [ ] Implement handle(ListPaymentsByInvoiceQuery query) method
  - [ ] Fetch invoice to validate existence and get customer info
  - [ ] Fetch payments using paymentRepository.findByInvoiceId(invoiceId)
  - [ ] Sort payments by paymentDate ASC (chronological order)
  - [ ] For each payment, calculate running balance:
    - Start with invoice totalAmount
    - Subtract each payment amount cumulatively
    - Add runningBalance field to PaymentResponseDTO
  - [ ] Map payments to List<PaymentResponseDTO>
  - [ ] Include invoice number and customer name in each DTO
  - [ ] Return list sorted chronologically with running balances
  - [ ] Handle empty list gracefully (return empty list, not null)

- [ ] Create PaymentHistoryQuery and Handler (AC: 3, 4, 8)
  - [ ] Create PaymentHistoryQuery.java in features/payment/queries/
  - [ ] Define as record with fields:
    - Optional<UUID> customerId
    - Optional<LocalDate> startDate
    - Optional<LocalDate> endDate
    - Optional<PaymentMethod> paymentMethod
    - Pageable pageable (for pagination and sorting)
  - [ ] Create PaymentHistoryQueryHandler.java in features/payment/queries/
  - [ ] Annotate with @Service and @Transactional(readOnly = true)
  - [ ] Inject PaymentRepository (with custom query methods)
  - [ ] Implement handle(PaymentHistoryQuery query) method
  - [ ] Build dynamic query based on present Optional fields
  - [ ] Use Spring Data Specification or QueryDSL for dynamic filtering
  - [ ] If customerId present, join with Invoice to filter by customer
  - [ ] If startDate present, filter paymentDate >= startDate
  - [ ] If endDate present, filter paymentDate <= endDate
  - [ ] If paymentMethod present, filter by payment method
  - [ ] Apply pagination and sorting from Pageable
  - [ ] Default sort: paymentDate DESC (newest first)
  - [ ] Fetch related invoice and customer data (use JOIN FETCH to avoid N+1)
  - [ ] Map to Page<PaymentResponseDTO> with invoice and customer info
  - [ ] Return paginated result with total count

- [ ] Enhance PaymentRepository with query methods (AC: 3)
  - [ ] Add method: Page<Payment> findAll(Specification<Payment> spec, Pageable pageable)
  - [ ] Extend JpaSpecificationExecutor<Payment> for dynamic queries
  - [ ] Create PaymentSpecification utility class in queries/
  - [ ] Add static method: Specification<Payment> byCustomerId(UUID customerId)
    - Join payment -> invoice -> customer
    - Filter by customer.id = customerId
  - [ ] Add static method: Specification<Payment> byDateRange(LocalDate start, LocalDate end)
    - Filter paymentDate between start and end
  - [ ] Add static method: Specification<Payment> byPaymentMethod(PaymentMethod method)
    - Filter paymentMethod = method
  - [ ] Add method to combine specifications: Specification.where(spec1).and(spec2)
  - [ ] Add custom query with JOIN FETCH for eager loading:
    @Query("SELECT p FROM Payment p JOIN FETCH p.invoice i JOIN FETCH i.customer WHERE ...")
  - [ ] Optimize queries to avoid N+1 problem

- [ ] Create GetPaymentStatisticsQuery and Handler (AC: 6)
  - [ ] Create GetPaymentStatisticsQuery.java in features/payment/queries/
  - [ ] Define as record with optional date range filters
  - [ ] Create PaymentStatisticsDTO.java in features/payment/queries/
  - [ ] Fields: BigDecimal totalCollected, Map<PaymentMethod, BigDecimal> byMethod
  - [ ] Fields: BigDecimal collectedToday, BigDecimal collectedThisMonth
  - [ ] Fields: int totalPaymentCount
  - [ ] Create GetPaymentStatisticsQueryHandler.java in features/payment/queries/
  - [ ] Annotate with @Service and @Transactional(readOnly = true)
  - [ ] Inject PaymentRepository
  - [ ] Implement handle(GetPaymentStatisticsQuery query) method
  - [ ] Query totalCollected: SUM(amount) from all payments
  - [ ] Query by method: SUM(amount) GROUP BY paymentMethod
  - [ ] Query today's total: SUM(amount) WHERE paymentDate = today
  - [ ] Query this month's total: SUM(amount) WHERE paymentDate in current month
  - [ ] Use native queries or JPQL aggregations
  - [ ] Map results to PaymentStatisticsDTO
  - [ ] Return statistics for dashboard display

- [ ] Create PaymentQueryController (AC: 5)
  - [ ] Create PaymentQueryController.java in features/payment/api/
  - [ ] Annotate with @RestController and @RequestMapping("/api/payments")
  - [ ] Inject query handlers: GetPaymentByIdQueryHandler, PaymentHistoryQueryHandler
  - [ ] Also inject: GetPaymentStatisticsQueryHandler
  - [ ] Create endpoint: GET /api/payments/{id}
    - Path variable: @PathVariable UUID id
    - Call GetPaymentByIdQueryHandler.handle(new GetPaymentByIdQuery(id))
    - Return ResponseEntity.ok(response)
    - Add @PreAuthorize for authentication
    - Add OpenAPI annotations: @Operation, @ApiResponse
  - [ ] Create endpoint: GET /api/payments
    - Query params: customerId, startDate, endDate, paymentMethod, page, size, sort
    - Build PaymentHistoryQuery from params
    - Call PaymentHistoryQueryHandler.handle(query)
    - Return ResponseEntity.ok(pagedResult)
    - Add OpenAPI annotations documenting filters
  - [ ] Create endpoint: GET /api/payments/statistics
    - Optional query params: startDate, endDate
    - Call GetPaymentStatisticsQueryHandler.handle(query)
    - Return ResponseEntity.ok(statistics)
  - [ ] Add consistent error handling (404 if payment not found)
  - [ ] Document all endpoints with Swagger/OpenAPI

- [ ] Create InvoicePaymentQueryController (AC: 5)
  - [ ] Add methods to existing InvoiceQueryController (or create separate controller)
  - [ ] Create endpoint: GET /api/invoices/{id}/payments
    - Path variable: @PathVariable UUID id (invoice ID)
    - Inject ListPaymentsByInvoiceQueryHandler
    - Call handler.handle(new ListPaymentsByInvoiceQuery(id))
    - Return ResponseEntity.ok(payments)
    - Include running balance calculation in response
    - Add OpenAPI annotations
    - Document response includes payment history with running balances

- [ ] Enhance PaymentResponseDTO (AC: 4, 7, 8)
  - [ ] Update PaymentResponseDTO.java in features/payment/queries/
  - [ ] Add field: String invoiceNumber (from Invoice)
  - [ ] Add field: String customerName (from Customer via Invoice)
  - [ ] Add field: String customerEmail (for export)
  - [ ] Add field: BigDecimal invoiceTotal (for context)
  - [ ] Add field: BigDecimal remainingBalance (invoice balance after this payment)
  - [ ] Add field: BigDecimal runningBalance (for payment history - cumulative)
  - [ ] Add field: InvoiceStatus invoiceStatus (current invoice status)
  - [ ] Ensure all fields are properly mapped in PaymentMapper
  - [ ] Add JavaDoc comments explaining computed fields
  - [ ] Make DTO export-friendly (e.g., CSV-ready with flat structure)

- [ ] Create PaymentMapper utility (AC: 4, 7)
  - [ ] Create PaymentMapper.java in features/payment/queries/
  - [ ] Add method: toResponseDTO(Payment payment, Invoice invoice, Customer customer)
  - [ ] Map all Payment fields
  - [ ] Add invoice.getInvoiceNumber() as invoiceNumber
  - [ ] Add customer.getName() as customerName
  - [ ] Add customer.getEmail() as customerEmail
  - [ ] Add invoice.getTotalAmount() as invoiceTotal
  - [ ] Add invoice.getBalance() as remainingBalance
  - [ ] Calculate runningBalance if provided (for history queries)
  - [ ] Use MapStruct or manual mapping as per project convention
  - [ ] Add method: toResponseDTOList(List<Payment>, Invoice, Customer) for batch mapping

- [ ] Implement query performance optimization (AC: 3, 5)
  - [ ] Ensure queries use indexes (payments.invoice_id, payments.payment_date)
  - [ ] Use JOIN FETCH to eager load invoice and customer (avoid N+1 queries)
  - [ ] Add database indexes if missing:
    - CREATE INDEX idx_payments_payment_date ON payments(payment_date)
    - Already exists from Story 3.1
  - [ ] Test query performance with 1000+ payment records
  - [ ] Use EXPLAIN to analyze query execution plans
  - [ ] Optimize aggregation queries for statistics (use database-level SUM)
  - [ ] Consider read-only replicas for heavy query load (future)
  - [ ] Ensure payment queries meet <200ms requirement (PRD NFR1)

- [ ] Create comprehensive query tests (AC: 1-8)
  - [ ] Create GetPaymentByIdQueryHandlerTest.java
  - [ ] Test successful retrieval of payment with invoice details
  - [ ] Test EntityNotFoundException when payment not found
  - [ ] Test PaymentResponseDTO includes all expected fields
  - [ ] Create ListPaymentsByInvoiceQueryHandlerTest.java
  - [ ] Test retrieval of all payments for invoice
  - [ ] Test payments sorted chronologically
  - [ ] Test running balance calculation is correct
  - [ ] Test empty list when no payments for invoice
  - [ ] Create PaymentHistoryQueryHandlerTest.java
  - [ ] Test filtering by customer ID
  - [ ] Test filtering by date range
  - [ ] Test filtering by payment method
  - [ ] Test combined filters (customer + date range)
  - [ ] Test pagination (page size, total elements, total pages)
  - [ ] Test sorting by different fields (paymentDate, amount)
  - [ ] Create GetPaymentStatisticsQueryHandlerTest.java
  - [ ] Test total collected calculation
  - [ ] Test breakdown by payment method
  - [ ] Test today's total
  - [ ] Test this month's total
  - [ ] Use TestContainers with realistic test data
  - [ ] Achieve >85% code coverage on query logic

- [ ] Create API integration tests (AC: 5)
  - [ ] Create PaymentQueryControllerTest.java
  - [ ] Use @WebMvcTest or @SpringBootTest with MockMvc
  - [ ] Test GET /api/payments/{id} returns 200 OK with payment data
  - [ ] Test GET /api/payments/{id} returns 404 Not Found for invalid ID
  - [ ] Test GET /api/payments with no filters returns paginated list
  - [ ] Test GET /api/payments with customer filter
  - [ ] Test GET /api/payments with date range filter
  - [ ] Test GET /api/payments with payment method filter
  - [ ] Test GET /api/payments pagination (page, size parameters)
  - [ ] Test GET /api/payments sorting (sort parameter)
  - [ ] Test GET /api/payments/statistics returns aggregated data
  - [ ] Test GET /api/invoices/{id}/payments returns payment history
  - [ ] Test GET without authentication returns 401 Unauthorized
  - [ ] Verify JSON response structure matches PaymentResponseDTO
  - [ ] Use MockBean for query handlers in unit tests

- [ ] Add payment history to dashboard (AC: 6)
  - [ ] This is backend preparation for frontend dashboard
  - [ ] Ensure GET /api/payments/statistics endpoint returns correct data
  - [ ] Include fields needed for dashboard charts:
    - Total collected (all time)
    - Collected today
    - Collected this month
    - Breakdown by payment method
    - Payment count
  - [ ] Test statistics endpoint performance (<200ms)
  - [ ] Consider caching statistics for dashboard (Redis or in-memory)
  - [ ] Document expected frontend usage in API docs

- [ ] Implement export-ready format (AC: 8)
  - [ ] Ensure PaymentResponseDTO has flat structure (no nested objects)
  - [ ] Include all fields needed for accounting:
    - Payment ID, date, amount, method, reference
    - Invoice number, customer name, customer email
    - Invoice total, remaining balance, running balance
  - [ ] Add CSV export endpoint (optional, future enhancement):
    - GET /api/payments/export?format=csv
    - Returns CSV file with payment history
    - Include all PaymentResponseDTO fields
  - [ ] Add Excel export endpoint (optional):
    - GET /api/payments/export?format=xlsx
  - [ ] Document export format in API specification
  - [ ] Note: Export endpoints may be implemented in Story 4.x

- [ ] Add OpenAPI documentation (AC: 5)
  - [ ] Annotate PaymentQueryController with @Tag("Payment Queries")
  - [ ] Add @Operation annotations to all endpoints
  - [ ] GET /api/payments/{id}:
    - Summary: "Get payment by ID"
    - Description: "Retrieves payment details with invoice and customer information"
  - [ ] GET /api/payments:
    - Summary: "List payments with filters"
    - Description: "Retrieves paginated payment history with optional filters"
    - Document query parameters: customerId, startDate, endDate, paymentMethod, page, size, sort
  - [ ] GET /api/payments/statistics:
    - Summary: "Get payment statistics"
    - Description: "Retrieves aggregated payment statistics for dashboard"
  - [ ] GET /api/invoices/{id}/payments:
    - Summary: "Get payments for invoice"
    - Description: "Retrieves all payments for specific invoice with running balance"
  - [ ] Add example responses for all endpoints
  - [ ] Add error response examples (404, 400, 401)
  - [ ] Test Swagger UI renders payment endpoints correctly

- [ ] Add comprehensive logging (AC: 1-8)
  - [ ] Add SLF4J Logger to all query handlers
  - [ ] Log info: "Retrieved payment {paymentId}"
  - [ ] Log info: "Retrieved {count} payments for invoice {invoiceId}"
  - [ ] Log info: "Payment history query returned {totalElements} results"
  - [ ] Log debug: "Query filters: customerId={}, dateRange={}, method={}"
  - [ ] Log warning: "Payment not found: {paymentId}" (before throwing exception)
  - [ ] Log error: "Unexpected error in payment query: {exception}" (on failures)
  - [ ] Use correlation ID (MDC) for request tracing
  - [ ] Ensure query logging doesn't impact performance

- [ ] Create read model optimization (AC: 6, 7)
  - [ ] Consider denormalized read models for complex queries
  - [ ] Create materialized view for payment statistics (optional):
    - View aggregates payments by method, date, customer
    - Refresh on payment insert (trigger or scheduled job)
    - Improves dashboard query performance
  - [ ] Use database-level aggregation for statistics (SUM, GROUP BY)
  - [ ] Avoid application-level aggregation (slow for large datasets)
  - [ ] Test query performance with 10,000+ payment records
  - [ ] Profile slow queries and optimize as needed

- [ ] Add payment query caching (optional performance enhancement)
  - [ ] Add @Cacheable annotation to frequently accessed queries
  - [ ] Cache payment statistics (TTL: 5 minutes)
  - [ ] Cache individual payment lookups (TTL: 10 minutes)
  - [ ] Invalidate cache on payment creation (@CacheEvict)
  - [ ] Use Spring Cache with Caffeine or Redis
  - [ ] Test cache hit/miss ratios
  - [ ] Note: Caching may be deferred to Story 4.3 (Performance Optimization)

## Dev Notes

### Previous Story Insights

**Story 3.2 Completion:**
Story 3.2 implemented payment recording commands:
- RecordPaymentCommand and RecordPaymentCommandHandler
- POST /api/invoices/{id}/payments endpoint
- Transactional payment recording with invoice balance update
- Invoice status transition to Paid when balance reaches zero
- PaymentRecorded domain event
- Idempotency handling for duplicate prevention
- Comprehensive integration and API tests

**Story 3.1 Completion:**
Story 3.1 implemented the Payment domain model:
- Payment entity with validation logic
- PaymentMethod enum
- PaymentRepository interface
- PaymentService for reconciliation logic
- Database migration for payments table
- Unit tests for domain logic

**Epic 2 Query Patterns:**
Stories 2.3 and 2.4 established query patterns:
- Query classes as immutable records
- QueryHandler services with @Transactional(readOnly = true)
- Separate read models (DTOs) optimized for UI
- Pagination support with Spring Data Pageable
- Dynamic filtering with Specifications
- QueryController with GET endpoints
- OpenAPI documentation for all queries

**Epic 1 Query Patterns:**
Story 1.4 implemented Customer query operations:
- GetCustomerByIdQuery, ListCustomersQuery
- CustomerQueryRepository with projections
- Separate CustomerResponseDTO for UI
- Pagination, sorting, filtering support
- OpenAPI/Swagger documentation

### Data Models

**PaymentResponseDTO** [Source: architecture.md#Data Models, Enhanced for AC 4, 7, 8]:
```java
package com.invoiceme.features.payment.queries;

import com.invoiceme.features.invoice.domain.InvoiceStatus;
import com.invoiceme.features.payment.domain.PaymentMethod;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Enhanced DTO for payment queries with invoice and customer context.
 * Export-ready format for accounting reconciliation.
 */
public record PaymentResponseDTO(
    UUID id,
    UUID invoiceId,
    String invoiceNumber,           // From Invoice
    String customerName,            // From Customer via Invoice
    String customerEmail,           // From Customer (for export)
    LocalDate paymentDate,
    BigDecimal amount,
    PaymentMethod paymentMethod,
    String reference,
    String notes,
    BigDecimal invoiceTotal,        // Invoice total amount (context)
    BigDecimal remainingBalance,    // Invoice balance after this payment
    BigDecimal runningBalance,      // Cumulative balance (for payment history)
    InvoiceStatus invoiceStatus,    // Current invoice status
    LocalDateTime createdAt,
    String createdBy
) {}
```

**PaymentHistoryQuery** [Derived from PRD Epic 3 Story 3.3 AC 3]:
```java
package com.invoiceme.features.payment.queries;

import com.invoiceme.features.payment.domain.PaymentMethod;
import org.springframework.data.domain.Pageable;
import java.time.LocalDate;
import java.util.Optional;
import java.util.UUID;

/**
 * Query for payment history with dynamic filtering.
 * Supports pagination and sorting via Spring Data Pageable.
 */
public record PaymentHistoryQuery(
    Optional<UUID> customerId,
    Optional<LocalDate> startDate,
    Optional<LocalDate> endDate,
    Optional<PaymentMethod> paymentMethod,
    Pageable pageable
) {
    // Factory methods for common queries
    public static PaymentHistoryQuery allPayments(Pageable pageable) {
        return new PaymentHistoryQuery(
            Optional.empty(),
            Optional.empty(),
            Optional.empty(),
            Optional.empty(),
            pageable
        );
    }

    public static PaymentHistoryQuery forCustomer(UUID customerId, Pageable pageable) {
        return new PaymentHistoryQuery(
            Optional.of(customerId),
            Optional.empty(),
            Optional.empty(),
            Optional.empty(),
            pageable
        );
    }

    public static PaymentHistoryQuery forDateRange(LocalDate start, LocalDate end, Pageable pageable) {
        return new PaymentHistoryQuery(
            Optional.empty(),
            Optional.of(start),
            Optional.of(end),
            Optional.empty(),
            pageable
        );
    }
}
```

**PaymentStatisticsDTO** [Derived from PRD Epic 3 Story 3.3 AC 6]:
```java
package com.invoiceme.features.payment.queries;

import com.invoiceme.features.payment.domain.PaymentMethod;
import java.math.BigDecimal;
import java.util.Map;

/**
 * DTO for payment statistics used in dashboard.
 * Contains aggregated payment data by various dimensions.
 */
public record PaymentStatisticsDTO(
    BigDecimal totalCollected,                      // All-time total
    BigDecimal collectedToday,                      // Today's payments
    BigDecimal collectedThisMonth,                  // Current month's payments
    BigDecimal collectedThisYear,                   // Current year's payments
    int totalPaymentCount,                          // Total number of payments
    Map<PaymentMethod, BigDecimal> byMethod,        // Breakdown by payment method
    Map<String, BigDecimal> byMonth                 // Monthly breakdown (last 12 months)
) {}
```

**TypeScript Interfaces** [Source: architecture.md#Data Models]:
```typescript
interface PaymentResponseDTO {
  id: string;
  invoiceId: string;
  invoiceNumber: string;
  customerName: string;
  customerEmail: string;
  paymentDate: Date;
  amount: number;
  paymentMethod: PaymentMethod;
  reference: string;
  notes?: string;
  invoiceTotal: number;
  remainingBalance: number;
  runningBalance?: number;    // Only in payment history queries
  invoiceStatus: InvoiceStatus;
  createdAt: Date;
  createdBy: string;
}

interface PaymentHistoryFilters {
  customerId?: string;
  startDate?: Date;
  endDate?: Date;
  paymentMethod?: PaymentMethod;
  page?: number;
  size?: number;
  sort?: string;
}

interface PaymentStatistics {
  totalCollected: number;
  collectedToday: number;
  collectedThisMonth: number;
  collectedThisYear: number;
  totalPaymentCount: number;
  byMethod: Record<PaymentMethod, number>;
  byMonth: Record<string, number>;  // "2024-11": 1500.00
}
```

### API Specifications

**GET /api/payments/{id}** [Derived from PRD Epic 3 Story 3.3 AC 1, 4, 5]:

**Request:**
```
GET /api/payments/{id}
Authorization: Bearer {jwt_token}
```

**Response (200 OK):**
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "invoiceId": "660e8400-e29b-41d4-a716-446655440000",
  "invoiceNumber": "INV-2024-0123",
  "customerName": "Acme Corporation",
  "customerEmail": "billing@acme.com",
  "paymentDate": "2024-11-08",
  "amount": 250.00,
  "paymentMethod": "CreditCard",
  "reference": "VISA-****-1234",
  "notes": "Partial payment received",
  "invoiceTotal": 500.00,
  "remainingBalance": 250.00,
  "invoiceStatus": "Sent",
  "createdAt": "2024-11-08T14:30:00Z",
  "createdBy": "user@example.com"
}
```

**Response (404 Not Found):**
```json
{
  "timestamp": "2024-11-08T14:30:00Z",
  "status": 404,
  "error": "Not Found",
  "message": "Payment not found with id: 550e8400-e29b-41d4-a716-446655440000"
}
```

**GET /api/payments** [Derived from PRD Epic 3 Story 3.3 AC 3, 5]:

**Request:**
```
GET /api/payments?customerId=770e8400&startDate=2024-01-01&endDate=2024-12-31&paymentMethod=CreditCard&page=0&size=20&sort=paymentDate,desc
Authorization: Bearer {jwt_token}
```

**Response (200 OK):**
```json
{
  "content": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "invoiceId": "660e8400-e29b-41d4-a716-446655440000",
      "invoiceNumber": "INV-2024-0123",
      "customerName": "Acme Corporation",
      "customerEmail": "billing@acme.com",
      "paymentDate": "2024-11-08",
      "amount": 250.00,
      "paymentMethod": "CreditCard",
      "reference": "VISA-****-1234",
      "notes": null,
      "invoiceTotal": 500.00,
      "remainingBalance": 250.00,
      "invoiceStatus": "Sent",
      "createdAt": "2024-11-08T14:30:00Z",
      "createdBy": "user@example.com"
    }
  ],
  "page": 0,
  "size": 20,
  "totalElements": 45,
  "totalPages": 3
}
```

**GET /api/invoices/{id}/payments** [Derived from PRD Epic 3 Story 3.3 AC 2, 5, 7]:

**Request:**
```
GET /api/invoices/660e8400-e29b-41d4-a716-446655440000/payments
Authorization: Bearer {jwt_token}
```

**Response (200 OK):**
```json
[
  {
    "id": "550e8400-1",
    "invoiceId": "660e8400",
    "invoiceNumber": "INV-2024-0123",
    "customerName": "Acme Corporation",
    "paymentDate": "2024-11-01",
    "amount": 200.00,
    "paymentMethod": "BankTransfer",
    "reference": "WIRE-001",
    "invoiceTotal": 500.00,
    "remainingBalance": 300.00,
    "runningBalance": 300.00,
    "invoiceStatus": "Sent"
  },
  {
    "id": "550e8400-2",
    "invoiceId": "660e8400",
    "invoiceNumber": "INV-2024-0123",
    "customerName": "Acme Corporation",
    "paymentDate": "2024-11-08",
    "amount": 100.00,
    "paymentMethod": "CreditCard",
    "reference": "VISA-1234",
    "invoiceTotal": 500.00,
    "remainingBalance": 200.00,
    "runningBalance": 200.00,
    "invoiceStatus": "Sent"
  }
]
```

**GET /api/payments/statistics** [Derived from PRD Epic 3 Story 3.3 AC 6]:

**Request:**
```
GET /api/payments/statistics?startDate=2024-01-01&endDate=2024-12-31
Authorization: Bearer {jwt_token}
```

**Response (200 OK):**
```json
{
  "totalCollected": 125000.00,
  "collectedToday": 1500.00,
  "collectedThisMonth": 15000.00,
  "collectedThisYear": 125000.00,
  "totalPaymentCount": 342,
  "byMethod": {
    "CreditCard": 50000.00,
    "BankTransfer": 60000.00,
    "Check": 10000.00,
    "Cash": 5000.00
  },
  "byMonth": {
    "2024-01": 10000.00,
    "2024-02": 12000.00,
    "2024-03": 11000.00,
    "2024-04": 13000.00,
    "2024-05": 10500.00,
    "2024-06": 9500.00,
    "2024-07": 11500.00,
    "2024-08": 12500.00,
    "2024-09": 10000.00,
    "2024-10": 11000.00,
    "2024-11": 9000.00,
    "2024-12": 5000.00
  }
}
```

### Component Specifications

**GetPaymentByIdQueryHandler** [Derived from PRD Epic 3 Story 3.3 AC 1]:
- Location: backend/src/main/java/com/invoiceme/features/payment/queries/GetPaymentByIdQueryHandler.java
- Responsibility: Retrieve single payment with invoice and customer details
- Dependencies: PaymentRepository, InvoiceRepository
- Read-only: @Transactional(readOnly = true)
- Error Handling: Throws EntityNotFoundException if payment not found

**ListPaymentsByInvoiceQueryHandler** [Derived from PRD Epic 3 Story 3.3 AC 2, 7]:
- Location: backend/src/main/java/com/invoiceme/features/payment/queries/ListPaymentsByInvoiceQueryHandler.java
- Responsibility: Retrieve all payments for specific invoice with running balance
- Dependencies: PaymentRepository, InvoiceRepository
- Running Balance Calculation:
  - Start with invoice total amount
  - For each payment (chronological order):
    - Subtract payment amount
    - Record running balance at that point
- Sorting: Payments ordered by paymentDate ASC

**PaymentHistoryQueryHandler** [Derived from PRD Epic 3 Story 3.3 AC 3]:
- Location: backend/src/main/java/com/invoiceme/features/payment/queries/PaymentHistoryQueryHandler.java
- Responsibility: Retrieve paginated payment history with dynamic filters
- Dependencies: PaymentRepository (with Specification support)
- Filtering: Build Specification from Optional fields in query
- Pagination: Use Spring Data Pageable
- Performance: Use JOIN FETCH to avoid N+1 queries

**GetPaymentStatisticsQueryHandler** [Derived from PRD Epic 3 Story 3.3 AC 6]:
- Location: backend/src/main/java/com/invoiceme/features/payment/queries/GetPaymentStatisticsQueryHandler.java
- Responsibility: Calculate aggregated payment statistics for dashboard
- Dependencies: PaymentRepository (with custom aggregation queries)
- Aggregations:
  - Total collected: SUM(amount)
  - By method: SUM(amount) GROUP BY paymentMethod
  - By month: SUM(amount) GROUP BY MONTH(paymentDate)
- Performance: Use database-level aggregation (not application-level)

**PaymentSpecification** [Derived from PRD Epic 3 Story 3.3 AC 3]:
- Location: backend/src/main/java/com/invoiceme/features/payment/queries/PaymentSpecification.java
- Responsibility: Build dynamic query specifications for filtering
- Methods:
  - `byCustomerId(UUID customerId)` - Join payment -> invoice -> customer
  - `byDateRange(LocalDate start, LocalDate end)` - Filter paymentDate
  - `byPaymentMethod(PaymentMethod method)` - Filter paymentMethod
- Usage: `Specification.where(byCustomerId).and(byDateRange).and(byPaymentMethod)`

### File Locations

**Backend Files** [Source: architecture.md#Unified Project Structure]:
```
backend/src/main/java/com/invoiceme/features/payment/
├── queries/
│   ├── GetPaymentByIdQuery.java                  # Query DTO
│   ├── GetPaymentByIdQueryHandler.java           # Handler
│   ├── ListPaymentsByInvoiceQuery.java           # Query DTO
│   ├── ListPaymentsByInvoiceQueryHandler.java    # Handler
│   ├── PaymentHistoryQuery.java                  # Query DTO with filters
│   ├── PaymentHistoryQueryHandler.java           # Handler with Specification
│   ├── GetPaymentStatisticsQuery.java            # Query DTO
│   ├── GetPaymentStatisticsQueryHandler.java     # Handler
│   ├── PaymentResponseDTO.java                   # Enhanced DTO
│   ├── PaymentStatisticsDTO.java                 # Statistics DTO
│   ├── PaymentSpecification.java                 # Query specifications
│   └── PaymentMapper.java                        # Entity to DTO mapper
├── domain/
│   └── PaymentRepository.java                    # Add Specification support
└── api/
    ├── PaymentQueryController.java               # GET /api/payments/*
    └── InvoiceQueryController.java               # Add GET /api/invoices/{id}/payments

backend/src/test/java/com/invoiceme/features/payment/
├── queries/
│   ├── GetPaymentByIdQueryHandlerTest.java
│   ├── ListPaymentsByInvoiceQueryHandlerTest.java
│   ├── PaymentHistoryQueryHandlerTest.java
│   ├── GetPaymentStatisticsQueryHandlerTest.java
│   └── PaymentSpecificationTest.java
└── api/
    └── PaymentQueryControllerTest.java
```

### Testing Requirements

**Testing Strategy** [Source: architecture.md#Tech Stack, PRD Technical Assumptions]:
- Query handler integration tests with TestContainers
- Test query results with realistic data
- Test pagination, sorting, filtering
- Test running balance calculation accuracy
- Test aggregation queries for statistics
- API tests for all GET endpoints
- Performance tests for query response times (<200ms)
- Minimum 85% code coverage on query logic

**Query Handler Test Structure**:
```java
@SpringBootTest
@Transactional
@DisplayName("ListPaymentsByInvoiceQueryHandler Tests")
class ListPaymentsByInvoiceQueryHandlerTest {

    @Autowired
    private ListPaymentsByInvoiceQueryHandler handler;

    @Autowired
    private InvoiceRepository invoiceRepository;

    @Autowired
    private PaymentRepository paymentRepository;

    @Test
    @DisplayName("Should return payments with running balance calculation")
    void shouldReturnPaymentsWithRunningBalance() {
        // Given: Invoice with total $500 and 3 payments
        Invoice invoice = InvoiceTestBuilder.aInvoice()
            .withTotalAmount(new BigDecimal("500.00"))
            .withBalance(new BigDecimal("100.00"))
            .build();
        invoice = invoiceRepository.save(invoice);

        Payment payment1 = PaymentTestBuilder.aPayment()
            .withInvoiceId(invoice.getId())
            .withPaymentDate(LocalDate.of(2024, 11, 1))
            .withAmount(new BigDecimal("200.00"))
            .build();
        paymentRepository.save(payment1);

        Payment payment2 = PaymentTestBuilder.aPayment()
            .withInvoiceId(invoice.getId())
            .withPaymentDate(LocalDate.of(2024, 11, 5))
            .withAmount(new BigDecimal("100.00"))
            .build();
        paymentRepository.save(payment2);

        Payment payment3 = PaymentTestBuilder.aPayment()
            .withInvoiceId(invoice.getId())
            .withPaymentDate(LocalDate.of(2024, 11, 8))
            .withAmount(new BigDecimal("100.00"))
            .build();
        paymentRepository.save(payment3);

        // When: List payments for invoice
        ListPaymentsByInvoiceQuery query = new ListPaymentsByInvoiceQuery(invoice.getId());
        List<PaymentResponseDTO> payments = handler.handle(query);

        // Then: Payments returned with correct running balances
        assertThat(payments).hasSize(3);

        // First payment: $500 - $200 = $300
        assertThat(payments.get(0).amount()).isEqualByComparingTo(new BigDecimal("200.00"));
        assertThat(payments.get(0).runningBalance()).isEqualByComparingTo(new BigDecimal("300.00"));

        // Second payment: $300 - $100 = $200
        assertThat(payments.get(1).amount()).isEqualByComparingTo(new BigDecimal("100.00"));
        assertThat(payments.get(1).runningBalance()).isEqualByComparingTo(new BigDecimal("200.00"));

        // Third payment: $200 - $100 = $100
        assertThat(payments.get(2).amount()).isEqualByComparingTo(new BigDecimal("100.00"));
        assertThat(payments.get(2).runningBalance()).isEqualByComparingTo(new BigDecimal("100.00"));
    }

    @Test
    @DisplayName("Should return empty list for invoice with no payments")
    void shouldReturnEmptyListForInvoiceWithNoPayments() {
        // Given: Invoice with no payments
        Invoice invoice = InvoiceTestBuilder.aInvoice().build();
        invoice = invoiceRepository.save(invoice);

        // When: List payments
        ListPaymentsByInvoiceQuery query = new ListPaymentsByInvoiceQuery(invoice.getId());
        List<PaymentResponseDTO> payments = handler.handle(query);

        // Then: Empty list returned
        assertThat(payments).isEmpty();
    }
}

@SpringBootTest
@DisplayName("PaymentHistoryQueryHandler Tests")
class PaymentHistoryQueryHandlerTest {

    @Autowired
    private PaymentHistoryQueryHandler handler;

    @Test
    @DisplayName("Should filter payments by customer ID")
    void shouldFilterPaymentsByCustomerId() {
        // Given: Payments for different customers
        UUID customer1Id = UUID.randomUUID();
        UUID customer2Id = UUID.randomUUID();
        // ... create invoices and payments for both customers

        // When: Query payments for customer1
        PaymentHistoryQuery query = PaymentHistoryQuery.forCustomer(
            customer1Id,
            PageRequest.of(0, 20)
        );
        Page<PaymentResponseDTO> result = handler.handle(query);

        // Then: Only customer1's payments returned
        assertThat(result.getContent()).allMatch(p -> p.customerId().equals(customer1Id));
    }

    @Test
    @DisplayName("Should filter payments by date range")
    void shouldFilterPaymentsByDateRange() {
        // Given: Payments across multiple dates
        LocalDate start = LocalDate.of(2024, 11, 1);
        LocalDate end = LocalDate.of(2024, 11, 30);

        // When: Query payments for November
        PaymentHistoryQuery query = PaymentHistoryQuery.forDateRange(
            start, end, PageRequest.of(0, 20)
        );
        Page<PaymentResponseDTO> result = handler.handle(query);

        // Then: Only November payments returned
        assertThat(result.getContent()).allMatch(p ->
            !p.paymentDate().isBefore(start) && !p.paymentDate().isAfter(end)
        );
    }

    @Test
    @DisplayName("Should paginate results correctly")
    void shouldPaginateResultsCorrectly() {
        // Given: 50 payments in database
        // ... create 50 payments

        // When: Request page 2 with size 20
        PaymentHistoryQuery query = PaymentHistoryQuery.allPayments(
            PageRequest.of(1, 20, Sort.by("paymentDate").descending())
        );
        Page<PaymentResponseDTO> result = handler.handle(query);

        // Then: Page 2 returned with correct metadata
        assertThat(result.getNumber()).isEqualTo(1);
        assertThat(result.getSize()).isEqualTo(20);
        assertThat(result.getTotalElements()).isEqualTo(50);
        assertThat(result.getTotalPages()).isEqualTo(3);
        assertThat(result.getContent()).hasSize(20);
    }
}
```

### Technical Constraints

**Dependencies** [Source: architecture.md#Tech Stack]:
- Spring Boot 3.2.x
- Spring Data JPA with Specification support
- PostgreSQL 15
- Jackson for JSON serialization
- OpenAPI/Swagger for API documentation
- JUnit 5, Mockito for testing
- TestContainers for integration tests

**Performance Requirements** [Source: PRD NFR1]:
- Query response times: <200ms for standard queries
- Payment list query: <100ms for 1000 records
- Statistics query: <150ms with aggregations
- Use database indexes on frequently queried fields
- Optimize JOIN queries to avoid N+1 problems
- Use database-level aggregation for statistics

**Query Optimization** [Source: architecture.md#Architectural Patterns]:
- Use JOIN FETCH for eager loading related entities
- Apply indexes on: payment_date, invoice_id, payment_method
- Use read-only transactions: @Transactional(readOnly = true)
- Consider query result caching for statistics
- Use Specification API for dynamic filtering (avoid multiple repository methods)
- Profile queries with EXPLAIN to identify bottlenecks

**CQRS Separation** [Source: architecture.md#Architectural Patterns]:
- Query handlers are read-only (no state modification)
- Separate DTOs for queries (PaymentResponseDTO)
- Query endpoints use GET HTTP method
- No side effects in query operations
- Optimized read models (denormalized if needed)

**Pagination Standards**:
- Use Spring Data Pageable
- Default page size: 20
- Maximum page size: 100
- Support sorting by: paymentDate, amount, createdAt
- Default sort: paymentDate DESC (newest first)
- Return Page<T> with metadata: totalElements, totalPages

### Coding Standards

**Critical Backend Rules** [Source: architecture.md#Coding Standards]:
- Query handlers are read-only: @Transactional(readOnly = true)
- CQRS: Queries do not modify state
- Use Specification for dynamic filtering
- Use JOIN FETCH to avoid N+1 queries
- Return DTOs, never domain entities
- Use Pageable for pagination and sorting
- Optimize queries for performance (<200ms)

**Naming Conventions** [Source: architecture.md#Coding Standards]:
- Queries: Suffix with "Query" (GetPaymentByIdQuery)
- Query Handlers: Suffix with "QueryHandler"
- DTOs: Suffix with "DTO" (PaymentResponseDTO)
- Controllers: Suffix with "Controller"

**API Design Standards**:
- GET for all query endpoints
- Use plural nouns: /api/payments
- Use path parameters for IDs: /api/payments/{id}
- Use query parameters for filters: ?customerId=123&startDate=2024-01-01
- Return consistent JSON structure
- Include pagination metadata in responses
- Document with OpenAPI annotations

**Error Handling**:
- 404 Not Found for missing resources
- 400 Bad Request for invalid query parameters
- 401 Unauthorized for missing/invalid authentication
- Return ApiErrorResponse with details
- Log errors with context information

## Testing
- Unit tests for query handlers with mocked repositories
- Integration tests with TestContainers and real database
- Test GetPaymentByIdQuery returns payment with invoice details
- Test GetPaymentByIdQuery throws exception when not found
- Test ListPaymentsByInvoiceQuery returns chronological list
- Test running balance calculation is accurate
- Test PaymentHistoryQuery with customer filter
- Test PaymentHistoryQuery with date range filter
- Test PaymentHistoryQuery with payment method filter
- Test PaymentHistoryQuery with combined filters
- Test PaymentHistoryQuery pagination (page, size, totalElements)
- Test PaymentHistoryQuery sorting by different fields
- Test GetPaymentStatisticsQuery aggregations
- Test statistics total collected, by method, by month
- API tests for PaymentQueryController endpoints
- Test GET /api/payments/{id} returns 200 OK
- Test GET /api/payments/{id} returns 404 Not Found
- Test GET /api/payments with filters returns paginated results
- Test GET /api/payments/statistics returns aggregated data
- Test GET /api/invoices/{id}/payments returns payment history
- Test query performance with 1000+ payment records (<200ms)
- Test N+1 query prevention (use JOIN FETCH)
- Minimum 85% code coverage on query logic

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-11-08 | v1.0 | Initial story creation from PRD Epic 3 Story 3.3 | Claude (Story Agent) |

## Dev Agent Record

### Agent Model Used
Not yet implemented

### Debug Log References
None yet - will be populated during implementation

### Completion Notes List
None yet - will be populated during implementation

### File List
None yet - will be populated during implementation

## QA Results
Not yet reviewed
