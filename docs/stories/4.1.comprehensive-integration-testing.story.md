# Story 4.1: Comprehensive Integration Testing

## Status
Draft

## Story
**As a** developer,
**I want** to implement end-to-end integration tests,
**so that** we verify the complete business workflows function correctly.

## Acceptance Criteria
1. Integration test suite covering Customer→Invoice→Payment flow
2. Test data builders following builder pattern for test setup
3. Database test containers (TestContainers) for realistic testing
4. API integration tests for all REST endpoints with auth
5. CQRS verification tests ensuring command-query separation
6. State transition tests for invoice lifecycle
7. Negative test cases for error conditions and validation
8. Test coverage report showing >80% coverage on business logic

## Tasks / Subtasks
- [ ] Set up integration test infrastructure (AC: 3, 4)
  - [ ] Add TestContainers dependency to backend/pom.xml:
    ```xml
    <dependency>
      <groupId>org.testcontainers</groupId>
      <artifactId>testcontainers</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.testcontainers</groupId>
      <artifactId>postgresql</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.testcontainers</groupId>
      <artifactId>junit-jupiter</artifactId>
      <scope>test</scope>
    </dependency>
    ```
  - [ ] Create base test class: backend/src/test/java/com/invoiceme/IntegrationTestBase.java
  - [ ] Configure @SpringBootTest with random port
  - [ ] Configure @Testcontainers with PostgreSQL container
  - [ ] Set up TestRestTemplate or WebTestClient for API calls
  - [ ] Create test database initialization scripts
  - [ ] Configure test application.yml with TestContainers properties
  - [ ] Add @BeforeEach method to reset database state
  - [ ] Add helper methods for JWT token generation in tests
  - [ ] Configure test logging to show SQL statements (for debugging)

- [ ] Create test data builders (AC: 2)
  - [ ] Create CustomerTestBuilder.java in backend/src/test/java/com/invoiceme/builders/
    ```java
    public class CustomerTestBuilder {
      private String name = "Test Customer";
      private String email = "test@example.com";
      private String phone = "555-0100";
      private String address = "123 Test St";

      public CustomerTestBuilder withName(String name) { ... }
      public CustomerTestBuilder withEmail(String email) { ... }
      public Customer build() { ... }
      public CreateCustomerDTO buildDTO() { ... }
    }
    ```
  - [ ] Create InvoiceTestBuilder.java:
    - Builder for Invoice entity
    - Builder for CreateInvoiceDTO
    - Methods: withCustomer, withLineItem, withStatus, withDates
    - Default: Draft status, 1 line item, dates set to today
  - [ ] Create LineItemTestBuilder.java:
    - Builder for LineItem objects
    - Methods: withDescription, withQuantity, withUnitPrice, withDiscount, withTax
    - Default: quantity=1, unitPrice=100, no discount, no tax
  - [ ] Create PaymentTestBuilder.java:
    - Builder for Payment entity
    - Builder for RecordPaymentDTO
    - Methods: withInvoice, withAmount, withMethod, withDate
    - Default: amount=100, method=CreditCard, date=today
  - [ ] Add utility methods to builders:
    - buildAndSave(repository) - builds and persists to DB
    - buildList(int count) - creates multiple instances
    - withDefaults() - reset to default values

- [ ] Implement Customer→Invoice→Payment integration tests (AC: 1)
  - [ ] Create CustomerInvoicePaymentFlowTest.java
  - [ ] Test happy path end-to-end flow:
    - Create customer via POST /api/customers
    - Verify customer created with GET /api/customers/{id}
    - Create draft invoice for customer via POST /api/invoices
    - Add line items to invoice
    - Verify invoice total calculated correctly
    - Send invoice via POST /api/invoices/{id}/send
    - Verify invoice status changed to Sent
    - Record partial payment via POST /api/invoices/{id}/payments
    - Verify invoice balance updated correctly
    - Verify invoice status still Sent
    - Record final payment to complete balance
    - Verify invoice status changed to Paid
    - Verify invoice balance is zero
  - [ ] Test data consistency across all operations
  - [ ] Verify referential integrity maintained
  - [ ] Use assertions to verify each step
  - [ ] Clean up test data after test completion

- [ ] Create API integration tests for Customer endpoints (AC: 4)
  - [ ] Create CustomerApiIntegrationTest.java
  - [ ] Test POST /api/customers (Create):
    - Valid customer creation
    - Returns 201 Created
    - Response contains customer ID
    - Customer data matches request
  - [ ] Test GET /api/customers/{id} (GetById):
    - Existing customer returns 200 OK
    - Non-existent customer returns 404 Not Found
    - Response data matches created customer
  - [ ] Test GET /api/customers (List):
    - Returns paginated list
    - Supports search parameter
    - Supports pagination (page, size)
    - Returns correct total count
  - [ ] Test PUT /api/customers/{id} (Update):
    - Valid update returns 200 OK
    - Data updated correctly in database
    - Updated timestamp changed
  - [ ] Test DELETE /api/customers/{id} (Delete):
    - Successful delete returns 204 No Content
    - Soft delete: isDeleted flag set to true
    - Customer not returned in list queries
  - [ ] Test authentication required:
    - All endpoints return 401 without JWT
    - Valid JWT token allows access

- [ ] Create API integration tests for Invoice endpoints (AC: 4, 6)
  - [ ] Create InvoiceApiIntegrationTest.java
  - [ ] Test POST /api/invoices (Create):
    - Valid invoice with line items
    - Invoice number auto-generated
    - Status is Draft
    - Totals calculated correctly
    - Returns 201 Created
  - [ ] Test GET /api/invoices/{id} (GetById):
    - Returns invoice with line items
    - Includes customer information
    - Calculated fields present (subtotal, tax, total, balance)
  - [ ] Test GET /api/invoices (List):
    - Filter by customer ID
    - Filter by status (Draft, Sent, Paid)
    - Filter by date range
    - Pagination works correctly
  - [ ] Test PUT /api/invoices/{id} (Update):
    - Can update Draft invoices
    - Cannot update Sent invoices (returns 400)
    - Cannot update Paid invoices (returns 400)
    - Line items can be added/removed in Draft
    - Totals recalculated after update
  - [ ] Test POST /api/invoices/{id}/send (State transition):
    - Transitions Draft to Sent
    - Cannot send Sent or Paid invoices
    - Validation: must have at least one line item
    - Returns 200 OK on success
  - [ ] Test invoice number generation:
    - Format: INV-YYYY-NNNN
    - Sequential numbering
    - No duplicates

- [ ] Create API integration tests for Payment endpoints (AC: 4, 6)
  - [ ] Create PaymentApiIntegrationTest.java
  - [ ] Test POST /api/invoices/{id}/payments (RecordPayment):
    - Valid payment recorded
    - Invoice balance updated
    - Payment amount cannot exceed invoice balance
    - Cannot pay Draft invoices (returns 400)
    - Can pay Sent invoices
    - Cannot pay fully Paid invoices (balance=0)
    - Returns 201 Created
  - [ ] Test invoice status transition to Paid:
    - Record payment equal to invoice balance
    - Verify invoice status changed to Paid
    - Verify balance is zero
  - [ ] Test partial payment:
    - Record payment less than balance
    - Verify invoice status remains Sent
    - Verify balance reduced by payment amount
  - [ ] Test GET /api/invoices/{id}/payments (List payments):
    - Returns all payments for invoice
    - Sorted chronologically
    - Includes running balance
  - [ ] Test GET /api/payments (Global list):
    - Filter by customer
    - Filter by date range
    - Filter by payment method
    - Pagination works
  - [ ] Test GET /api/payments/{id} (GetById):
    - Returns payment with invoice and customer details

- [ ] Implement CQRS verification tests (AC: 5)
  - [ ] Create CQRSSeparationTest.java
  - [ ] Test command operations don't return domain entities:
    - Create commands return ID or success status
    - Update commands return ID or success status
    - Delete commands return void or success status
    - Commands don't return full entity data
  - [ ] Test query operations don't modify state:
    - GET requests don't change database
    - Query handlers are read-only
    - No side effects from queries
  - [ ] Test command/query handler separation:
    - Verify separate handler classes exist
    - Commands in .commands package
    - Queries in .queries package
    - No mixed command-query handlers
  - [ ] Test DTO separation:
    - Command DTOs used for writes
    - Response DTOs used for reads
    - No domain entities exposed directly

- [ ] Create state transition tests (AC: 6)
  - [ ] Create InvoiceStateTransitionTest.java
  - [ ] Test Draft → Sent transition:
    - SendInvoiceCommand on Draft succeeds
    - Status changes to Sent
    - Line items become immutable
  - [ ] Test Sent → Paid transition:
    - Occurs automatically when balance reaches zero
    - RecordPaymentCommand updates status
    - Cannot manually set Paid status
  - [ ] Test invalid transitions:
    - Cannot transition Sent → Draft
    - Cannot transition Paid → Sent
    - Cannot transition Paid → Draft
    - SendInvoiceCommand on Sent returns error
    - SendInvoiceCommand on Paid returns error
  - [ ] Test invariant enforcement:
    - Cannot modify line items after Sent
    - Cannot delete invoice with payments
    - Cannot delete customer with invoices
  - [ ] Test concurrent modification:
    - Use optimistic locking (@Version)
    - Concurrent updates throw exception
    - Retry logic handles conflicts

- [ ] Implement negative test cases (AC: 7)
  - [ ] Create ValidationErrorTest.java
  - [ ] Test customer validation errors:
    - Missing required fields (name, email)
    - Invalid email format
    - Duplicate email (if uniqueness required)
    - Empty or whitespace-only values
  - [ ] Test invoice validation errors:
    - Missing customer ID
    - Customer ID not found
    - Due date before issue date
    - No line items
    - Line item with zero or negative quantity
    - Line item with zero or negative unit price
    - Invalid discount percent (< 0 or > 1)
    - Invalid tax rate (< 0)
  - [ ] Test payment validation errors:
    - Payment amount zero or negative
    - Payment amount exceeds invoice balance
    - Payment on Draft invoice
    - Payment on fully Paid invoice
    - Invoice ID not found
    - Missing payment date
    - Future payment date (if not allowed)
  - [ ] Test authentication/authorization errors:
    - 401 Unauthorized without JWT
    - 401 Unauthorized with invalid JWT
    - 401 Unauthorized with expired JWT
  - [ ] Test database constraint violations:
    - Foreign key violations
    - Unique constraint violations
    - Not null constraint violations
  - [ ] Verify error response format:
    - Consistent error structure
    - HTTP status codes correct
    - Error messages user-friendly
    - Field-level errors for validation

- [ ] Add test coverage reporting (AC: 8)
  - [ ] Add JaCoCo plugin to backend/pom.xml:
    ```xml
    <plugin>
      <groupId>org.jacoco</groupId>
      <artifactId>jacoco-maven-plugin</artifactId>
      <version>0.8.11</version>
      <executions>
        <execution>
          <goals>
            <goal>prepare-agent</goal>
          </goals>
        </execution>
        <execution>
          <id>report</id>
          <phase>test</phase>
          <goals>
            <goal>report</goal>
          </goals>
        </execution>
        <execution>
          <id>jacoco-check</id>
          <goals>
            <goal>check</goal>
          </goals>
          <configuration>
            <rules>
              <rule>
                <element>PACKAGE</element>
                <limits>
                  <limit>
                    <counter>LINE</counter>
                    <value>COVEREDRATIO</value>
                    <minimum>0.80</minimum>
                  </limit>
                </limits>
              </rule>
            </rules>
          </configuration>
        </execution>
      </executions>
    </plugin>
    ```
  - [ ] Configure coverage exclusions:
    - Exclude DTOs (data classes only)
    - Exclude configuration classes
    - Exclude main application class
    - Focus on business logic coverage
  - [ ] Generate coverage report: mvn clean test jacoco:report
  - [ ] Verify HTML report generated: target/site/jacoco/index.html
  - [ ] Ensure >80% coverage on:
    - Command handlers
    - Query handlers
    - Domain entities with business logic
    - Service classes
  - [ ] Add coverage badge to README (optional)

- [ ] Create test utilities and helpers (AC: 1-8)
  - [ ] Create JwtTestHelper.java:
    - generateToken(username) - creates valid JWT for tests
    - getAuthHeader(username) - returns Bearer token header
    - extractUsername(token) - parses JWT token
  - [ ] Create ApiTestHelper.java:
    - postRequest(url, body, headers) - generic POST
    - getRequest(url, headers) - generic GET
    - putRequest(url, body, headers) - generic PUT
    - deleteRequest(url, headers) - generic DELETE
    - assertSuccessResponse(response) - common assertions
  - [ ] Create DatabaseTestHelper.java:
    - clearAllTables() - reset database state
    - createTestCustomer() - quick customer creation
    - createTestInvoice() - quick invoice creation
    - createTestPayment() - quick payment creation
    - assertDatabaseState() - verify expected DB state
  - [ ] Create AssertionHelper.java:
    - assertCustomerEquals(expected, actual)
    - assertInvoiceEquals(expected, actual)
    - assertPaymentEquals(expected, actual)
    - assertErrorResponse(response, expectedMessage)

- [ ] Add integration test for authentication flow (AC: 4)
  - [ ] Create AuthenticationIntegrationTest.java
  - [ ] Test POST /api/auth/login:
    - Valid credentials return JWT token
    - Invalid username returns 401
    - Invalid password returns 401
    - Response includes access token and refresh token
    - Response includes expiration time
  - [ ] Test POST /api/auth/refresh:
    - Valid refresh token returns new access token
    - Invalid refresh token returns 401
    - Expired refresh token returns 401
  - [ ] Test protected endpoints with JWT:
    - Valid token allows access
    - Invalid token returns 401
    - Expired token returns 401
    - Missing Authorization header returns 401
  - [ ] Test JWT token expiration:
    - Access token expires after configured time
    - Refresh token has longer expiration
  - [ ] Test logout (if implemented):
    - Clears tokens
    - Subsequent requests fail with 401

- [ ] Add integration test for dashboard queries (AC: 1, 4)
  - [ ] Create DashboardIntegrationTest.java
  - [ ] Test GET /api/dashboard/stats:
    - Returns total customer count
    - Returns invoice counts by status
    - Returns total revenue
    - Returns outstanding amount
    - Returns overdue amount
  - [ ] Test statistics accuracy:
    - Create test data (customers, invoices, payments)
    - Calculate expected statistics
    - Verify API returns correct values
  - [ ] Test real-time updates:
    - Create invoice, verify count incremented
    - Record payment, verify revenue updated
    - Send invoice, verify sent count updated

- [ ] Create test documentation (AC: 1-8)
  - [ ] Create backend/src/test/README.md
  - [ ] Document test structure and organization
  - [ ] Document how to run integration tests
  - [ ] Document test data builders usage
  - [ ] Document test helpers and utilities
  - [ ] Document TestContainers setup
  - [ ] Document coverage report generation
  - [ ] Add examples of writing new integration tests
  - [ ] Document common test patterns used

- [ ] Set up continuous integration for tests (AC: 8)
  - [ ] Ensure tests run in CI pipeline (GitHub Actions)
  - [ ] Configure CI to use TestContainers
  - [ ] Configure CI to generate coverage reports
  - [ ] Configure CI to fail build if coverage < 80%
  - [ ] Add test results reporting to CI
  - [ ] Optimize test execution time (parallel execution if possible)
  - [ ] Cache Maven dependencies in CI
  - [ ] Display coverage badge in PR checks

- [ ] Add performance tests for integration suite (AC: 1)
  - [ ] Measure test execution time
  - [ ] Optimize slow tests
  - [ ] Use @Transactional for test rollback (faster than manual cleanup)
  - [ ] Minimize database resets between tests
  - [ ] Use test data caching where appropriate
  - [ ] Target: Full integration test suite < 2 minutes

- [ ] Create integration tests for edge cases (AC: 7)
  - [ ] Test large invoice with many line items (100+)
  - [ ] Test customer with many invoices (1000+)
  - [ ] Test concurrent invoice creation (same customer)
  - [ ] Test concurrent payment recording (same invoice)
  - [ ] Test boundary values:
    - Zero amount (should fail)
    - Maximum decimal precision
    - Very large amounts
    - Date edge cases (leap years, month boundaries)
  - [ ] Test special characters in text fields
  - [ ] Test very long text values (address, notes)
  - [ ] Test null and empty string handling

## Dev Notes

### Previous Story Insights

**Epic 3 Completion:**
Epic 3 (Payment Processing & Reconciliation) is complete with all 5 stories:
- Story 3.1: Payment domain model with validation rules
- Story 3.2: Payment recording commands with transactional consistency
- Story 3.3: Payment queries with statistics and history
- Story 3.4: Payment recording UI with modal dialog
- Story 3.5: Payment history and reconciliation UI

Each story included unit tests for domain logic and API tests for endpoints, providing a foundation for integration testing.

**Epic 2 Testing Patterns:**
Stories 2.1-2.5 implemented Invoice domain with tests:
- Domain entity tests for business logic
- Command handler tests with mocked repositories
- Query handler tests for read operations
- API controller tests with MockMvc
- State transition tests for invoice lifecycle

**Epic 1 Testing Patterns:**
Stories 1.2-1.5 established testing patterns:
- Spring Boot test configuration
- MockMvc for API testing
- JUnit 5 test structure
- Mockito for mocking dependencies
- Test data setup in @BeforeEach

These patterns should be extended to integration tests with real database via TestContainers.

### Architecture Context

**Testing Strategy** [Source: architecture.md#Tech Stack]:
- Backend testing: JUnit 5 + Mockito
- Integration tests: Spring Boot Test + TestContainers
- API tests: MockMvc or WebTestClient
- Coverage tool: JaCoCo
- Target: >80% coverage on business logic

**Integration Test Requirements** [Source: PRD NFR8, Epic 4 Story 4.1]:
- End-to-end flows across modules (Customer→Invoice→Payment)
- TestContainers for realistic database testing
- Full CQRS verification
- State transition testing
- Negative test cases for error conditions
- Coverage reporting with JaCoCo

**Testing Tools** [Source: architecture.md#Tech Stack]:
| Tool | Version | Purpose |
|------|---------|---------|
| JUnit | 5.x | Unit and integration tests |
| Mockito | Latest | Mocking framework |
| TestContainers | Latest | Database test containers |
| Spring Boot Test | 3.2.x | Integration test support |
| JaCoCo | 0.8.11 | Code coverage reporting |

### Data Models

**Customer Entity** [Source: architecture.md#Data Models]:
```java
@Entity
@Table(name = "customers")
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String email;

    private String phone;

    private String address;

    @Column(nullable = false)
    private Boolean isDeleted = false;

    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(nullable = false)
    private LocalDateTime updatedAt;
}
```

**Invoice Entity** [Source: architecture.md#Data Models]:
```java
@Entity
@Table(name = "invoices")
public class Invoice {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(unique = true, nullable = false)
    private String invoiceNumber;

    @ManyToOne
    @JoinColumn(name = "customer_id", nullable = false)
    private Customer customer;

    @Column(nullable = false)
    private LocalDate issueDate;

    @Column(nullable = false)
    private LocalDate dueDate;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private InvoiceStatus status; // Draft, Sent, Paid

    private String paymentTerms;

    @Type(JsonBinaryType.class)
    @Column(columnDefinition = "jsonb", nullable = false)
    private List<LineItem> lineItems;

    @Column(nullable = false)
    private BigDecimal subtotal = BigDecimal.ZERO;

    @Column(nullable = false)
    private BigDecimal totalDiscount = BigDecimal.ZERO;

    @Column(nullable = false)
    private BigDecimal totalTax = BigDecimal.ZERO;

    @Column(nullable = false)
    private BigDecimal totalAmount = BigDecimal.ZERO;

    @Column(nullable = false)
    private BigDecimal balance = BigDecimal.ZERO;

    private String notes;

    @Version
    private Long version; // Optimistic locking
}
```

**Payment Entity** [Source: architecture.md#Data Models]:
```java
@Entity
@Table(name = "payments")
public class Payment {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @ManyToOne
    @JoinColumn(name = "invoice_id", nullable = false)
    private Invoice invoice;

    @Column(nullable = false)
    private LocalDate paymentDate;

    @Column(nullable = false)
    private BigDecimal amount;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PaymentMethod paymentMethod; // CreditCard, BankTransfer, Check, Cash

    @Column(nullable = false)
    private String reference;

    private String notes;

    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(nullable = false)
    private String createdBy;
}
```

### API Specifications

**API Endpoints to Test** [Source: architecture.md#REST API Specification]:

**Authentication:**
- POST /api/auth/login - Login with credentials
- POST /api/auth/refresh - Refresh access token

**Customer:**
- POST /api/customers - Create customer
- GET /api/customers/{id} - Get customer by ID
- GET /api/customers - List customers (with pagination, search)
- PUT /api/customers/{id} - Update customer
- DELETE /api/customers/{id} - Delete customer (soft delete)

**Invoice:**
- POST /api/invoices - Create invoice
- GET /api/invoices/{id} - Get invoice by ID
- GET /api/invoices - List invoices (with filters)
- PUT /api/invoices/{id} - Update invoice (Draft only)
- POST /api/invoices/{id}/send - Send invoice (state transition)

**Payment:**
- POST /api/invoices/{id}/payments - Record payment
- GET /api/invoices/{id}/payments - Get payments for invoice
- GET /api/payments - List all payments (with filters)
- GET /api/payments/{id} - Get payment by ID
- GET /api/payments/statistics - Get payment statistics

**Dashboard:**
- GET /api/dashboard/stats - Get dashboard statistics

### File Locations

**Backend Test Structure** [Source: architecture.md#Unified Project Structure]:
```
backend/src/test/
├── java/
│   └── com/
│       └── invoiceme/
│           ├── IntegrationTestBase.java               # Base class for integration tests (NEW)
│           ├── builders/                              # Test data builders (NEW)
│           │   ├── CustomerTestBuilder.java
│           │   ├── InvoiceTestBuilder.java
│           │   ├── LineItemTestBuilder.java
│           │   └── PaymentTestBuilder.java
│           ├── helpers/                               # Test utilities (NEW)
│           │   ├── JwtTestHelper.java
│           │   ├── ApiTestHelper.java
│           │   ├── DatabaseTestHelper.java
│           │   └── AssertionHelper.java
│           ├── integration/                           # Integration tests (NEW)
│           │   ├── CustomerInvoicePaymentFlowTest.java
│           │   ├── CustomerApiIntegrationTest.java
│           │   ├── InvoiceApiIntegrationTest.java
│           │   ├── PaymentApiIntegrationTest.java
│           │   ├── AuthenticationIntegrationTest.java
│           │   ├── DashboardIntegrationTest.java
│           │   ├── CQRSSeparationTest.java
│           │   ├── InvoiceStateTransitionTest.java
│           │   └── ValidationErrorTest.java
│           └── features/                              # Existing unit tests (KEEP)
│               ├── customer/
│               ├── invoice/
│               └── payment/
└── resources/
    ├── application-test.yml                          # Test configuration (NEW)
    └── test-data/                                    # Test data scripts (NEW)
        └── init.sql
```

**Coverage Report Location:**
```
backend/target/site/jacoco/
└── index.html                                        # Coverage report (GENERATED)
```

### Testing Requirements

**Integration Test Patterns** [Source: PRD Epic 4 Story 4.1]:
- Use @SpringBootTest for full application context
- Use @Testcontainers for PostgreSQL database
- Use TestRestTemplate or WebTestClient for API calls
- Use @Transactional for test isolation and rollback
- Use builders for test data creation
- Use helpers for common operations (JWT, API calls, assertions)

**Test Structure Example:**
```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@Testcontainers
@ActiveProfiles("test")
public class CustomerInvoicePaymentFlowTest extends IntegrationTestBase {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
        .withDatabaseName("invoiceme_test")
        .withUsername("test")
        .withPassword("test");

    @Autowired
    private TestRestTemplate restTemplate;

    @Autowired
    private CustomerRepository customerRepository;

    private String jwtToken;

    @BeforeEach
    void setUp() {
        // Clear database
        customerRepository.deleteAll();

        // Generate JWT token for tests
        jwtToken = JwtTestHelper.generateToken("testuser");
    }

    @Test
    void shouldCompleteCustomerToPaymentFlow() {
        // 1. Create customer
        CreateCustomerDTO customerDTO = CustomerTestBuilder.create()
            .withName("Acme Corporation")
            .withEmail("billing@acme.com")
            .buildDTO();

        ResponseEntity<CustomerResponseDTO> customerResponse =
            ApiTestHelper.post("/api/customers", customerDTO, jwtToken);

        assertThat(customerResponse.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        UUID customerId = customerResponse.getBody().getId();

        // 2. Create invoice
        CreateInvoiceDTO invoiceDTO = InvoiceTestBuilder.create()
            .withCustomerId(customerId)
            .withLineItem(LineItemTestBuilder.create()
                .withDescription("Consulting Services")
                .withQuantity(10)
                .withUnitPrice(new BigDecimal("100.00"))
                .build())
            .buildDTO();

        ResponseEntity<InvoiceResponseDTO> invoiceResponse =
            ApiTestHelper.post("/api/invoices", invoiceDTO, jwtToken);

        assertThat(invoiceResponse.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        assertThat(invoiceResponse.getBody().getTotalAmount())
            .isEqualByComparingTo(new BigDecimal("1000.00"));
        UUID invoiceId = invoiceResponse.getBody().getId();

        // 3. Send invoice
        ResponseEntity<Void> sendResponse =
            ApiTestHelper.post("/api/invoices/" + invoiceId + "/send", null, jwtToken);

        assertThat(sendResponse.getStatusCode()).isEqualTo(HttpStatus.OK);

        // 4. Record payment
        RecordPaymentDTO paymentDTO = PaymentTestBuilder.create()
            .withAmount(new BigDecimal("1000.00"))
            .withPaymentMethod(PaymentMethod.CREDIT_CARD)
            .withReference("VISA-1234")
            .buildDTO();

        ResponseEntity<PaymentResponseDTO> paymentResponse =
            ApiTestHelper.post("/api/invoices/" + invoiceId + "/payments", paymentDTO, jwtToken);

        assertThat(paymentResponse.getStatusCode()).isEqualTo(HttpStatus.CREATED);

        // 5. Verify invoice status changed to Paid
        ResponseEntity<InvoiceResponseDTO> updatedInvoice =
            ApiTestHelper.get("/api/invoices/" + invoiceId, jwtToken);

        assertThat(updatedInvoice.getBody().getStatus()).isEqualTo(InvoiceStatus.PAID);
        assertThat(updatedInvoice.getBody().getBalance()).isEqualByComparingTo(BigDecimal.ZERO);
    }
}
```

**Coverage Requirements** [Source: PRD Epic 4 Story 4.1 AC 8]:
- >80% line coverage on business logic
- 100% coverage on critical paths (payment recording, state transitions)
- Exclude DTOs, configuration classes from coverage metrics
- Focus coverage on:
  - Command handlers
  - Query handlers
  - Domain entities with business logic
  - Service classes

### Technical Constraints

**Dependencies** [Source: architecture.md#Tech Stack]:
- Spring Boot 3.2.x
- Java 17
- JUnit 5.x
- Mockito Latest
- TestContainers Latest
- PostgreSQL 15 (in container)
- JaCoCo 0.8.11

**TestContainers Configuration** [Source: PRD Technical Assumptions]:
- Use PostgreSQL container for realistic testing
- Container lifecycle: start before tests, stop after tests
- Database schema initialized via Flyway migrations
- Test data created programmatically (not from SQL dumps)

**Performance Requirements** [Source: PRD NFR1]:
- Integration test suite should complete in < 2 minutes
- Individual test execution < 5 seconds
- Use @Transactional for fast rollback instead of manual cleanup
- Optimize database resets between tests

### Coding Standards

**Critical Testing Rules** [Source: architecture.md#Coding Standards]:
- Use builders for test data creation (not constructors)
- Use helpers for common operations (JWT, API calls)
- Use meaningful test names describing the scenario
- Arrange-Act-Assert pattern in all tests
- One assertion concept per test
- Test both happy path and error cases
- Clean up test data after each test
- Don't rely on test execution order

**Test Naming Convention:**
- Format: `should{ExpectedBehavior}When{StateOrCondition}`
- Examples:
  - `shouldCreateCustomerWhenValidDataProvided()`
  - `shouldReturnNotFoundWhenCustomerDoesNotExist()`
  - `shouldTransitionInvoiceToPaidWhenFullPaymentRecorded()`
  - `shouldRejectPaymentWhenAmountExceedsBalance()`

**Assertion Libraries:**
- Use AssertJ for fluent assertions
- Example: `assertThat(actual).isEqualTo(expected)`
- Use custom assertion helpers for domain objects

**Test Organization:**
- Group related tests with @Nested classes
- Use @DisplayName for readable test descriptions
- Use @Tag for categorizing tests (e.g., @Tag("integration"))

## Testing
- All tests in this story ARE the testing
- Integration tests verify end-to-end functionality
- Test builders ensure consistent test data
- Coverage report validates >80% coverage
- Negative tests ensure proper error handling
- CQRS verification tests ensure architectural compliance
- State transition tests ensure business rule enforcement

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-11-08 | v1.0 | Initial story creation from PRD Epic 4 Story 4.1 | Claude (Story Agent) |

## Dev Agent Record

### Agent Model Used
Not yet implemented

### Debug Log References
None yet - will be populated during implementation

### Completion Notes List
None yet - will be populated during implementation

### File List
None yet - will be populated during implementation

## QA Results
Not yet reviewed
