# Story 3.1: Payment Domain Model

## Status
Draft

## Story
**As a** developer,
**I want** to implement the Payment entity with invoice application logic,
**so that** we can track payments and properly reconcile invoice balances.

## Acceptance Criteria
1. Payment entity with fields: id, invoiceId, paymentDate, amount, paymentMethod, reference, notes
2. PaymentMethod enum: CreditCard, BankTransfer, Check, Cash
3. Payment validation: amount must be positive, cannot exceed invoice balance
4. PaymentRepository interface following repository pattern
5. Domain service for payment-invoice reconciliation logic
6. Unit tests for payment validation and business rules
7. Database constraints ensuring referential integrity with invoices
8. Audit fields: createdAt, createdBy for payment tracking

## Tasks / Subtasks
- [ ] Create Payment domain entity (AC: 1, 2, 8)
  - [ ] Create Payment.java in backend/src/main/java/com/invoiceme/features/payment/domain/
  - [ ] Add entity annotation @Entity and table name @Table(name = "payments")
  - [ ] Add primary key field: UUID id with @Id and @GeneratedValue
  - [ ] Add field: UUID invoiceId with @Column(name = "invoice_id", nullable = false)
  - [ ] Add field: LocalDate paymentDate with @Column(name = "payment_date", nullable = false)
  - [ ] Add field: BigDecimal amount with @Column(precision = 10, scale = 2, nullable = false)
  - [ ] Add field: PaymentMethod paymentMethod with @Enumerated(EnumType.STRING)
  - [ ] Add field: String reference with @Column(length = 255)
  - [ ] Add field: String notes with @Column(columnDefinition = "TEXT")
  - [ ] Add audit field: LocalDateTime createdAt with @Column(name = "created_at")
  - [ ] Add audit field: String createdBy with @Column(name = "created_by", nullable = false)
  - [ ] Add @PrePersist method to auto-set createdAt to current timestamp
  - [ ] Add foreign key constraint annotation to invoiceId field
  - [ ] Implement equals() and hashCode() based on id
  - [ ] Add private constructor for JPA and public constructor with required fields
  - [ ] Add getter methods for all fields (no setters - immutable after creation)

- [ ] Create PaymentMethod enum (AC: 2)
  - [ ] Create PaymentMethod.java in backend/src/main/java/com/invoiceme/features/payment/domain/
  - [ ] Define enum values: CREDIT_CARD, BANK_TRANSFER, CHECK, CASH
  - [ ] Add constructor with display name field
  - [ ] Add getDisplayName() method for UI representation
  - [ ] Ensure enum can be persisted as STRING in database
  - [ ] Add JavaDoc comments explaining each payment method

- [ ] Implement Payment domain validation (AC: 3)
  - [ ] Add validateAmount() method in Payment entity
  - [ ] Check amount > 0, throw IllegalArgumentException if not
  - [ ] Add validatePaymentDate() method
  - [ ] Check paymentDate not in future, throw exception if invalid
  - [ ] Add static factory method: createPayment() that validates inputs
  - [ ] Validate required fields (invoiceId, amount, paymentMethod, paymentDate)
  - [ ] Add domain exception: InvalidPaymentException in common/exceptions/
  - [ ] Use InvalidPaymentException for business rule violations
  - [ ] Add validation annotations: @NotNull, @Positive on amount
  - [ ] Ensure validation runs before persistence (@PrePersist)

- [ ] Create PaymentRepository interface (AC: 4)
  - [ ] Create PaymentRepository.java in features/payment/domain/
  - [ ] Extend JpaRepository<Payment, UUID>
  - [ ] Add method: List<Payment> findByInvoiceId(UUID invoiceId)
  - [ ] Add method: Optional<Payment> findByIdAndInvoiceId(UUID id, UUID invoiceId)
  - [ ] Add method: List<Payment> findByPaymentDateBetween(LocalDate start, LocalDate end)
  - [ ] Add method: List<Payment> findByPaymentMethod(PaymentMethod method)
  - [ ] Add query annotation for findByInvoiceId with index hint
  - [ ] Add JavaDoc comments explaining repository methods
  - [ ] Follow repository pattern from Customer and Invoice domains

- [ ] Create Payment-Invoice reconciliation domain service (AC: 5)
  - [ ] Create PaymentService.java in features/payment/domain/
  - [ ] Annotate with @Service
  - [ ] Inject InvoiceRepository dependency
  - [ ] Add method: validatePaymentAgainstInvoice(Payment payment, Invoice invoice)
  - [ ] Check invoice exists and is not Draft (must be Sent to accept payment)
  - [ ] Check payment amount does not exceed invoice balance
  - [ ] Check invoice balance >= payment amount
  - [ ] Throw DomainException if validation fails with specific error messages
  - [ ] Add method: calculateNewBalance(Invoice invoice, BigDecimal paymentAmount)
  - [ ] Return invoice.getBalance().subtract(paymentAmount)
  - [ ] Add method: shouldMarkInvoiceAsPaid(BigDecimal newBalance)
  - [ ] Return true if newBalance equals zero or is very close (within 0.01)
  - [ ] Add JavaDoc explaining reconciliation business rules
  - [ ] Ensure service is stateless and thread-safe

- [ ] Create Payment DTOs (AC: 1, 2)
  - [ ] Create RecordPaymentDTO.java in features/payment/commands/
  - [ ] Add record fields: UUID invoiceId, LocalDate paymentDate, BigDecimal amount
  - [ ] Add fields: PaymentMethod paymentMethod, String reference, String notes
  - [ ] Add validation annotations: @NotNull on required fields
  - [ ] Add @Positive annotation on amount
  - [ ] Create PaymentResponseDTO.java in features/payment/queries/
  - [ ] Add all Payment entity fields plus computed fields
  - [ ] Add field: String invoiceNumber (joined from Invoice)
  - [ ] Add field: String customerName (joined from Customer through Invoice)
  - [ ] Add field: BigDecimal remainingBalance (invoice balance after payment)
  - [ ] Create mapper: PaymentMapper.java in features/payment/
  - [ ] Add method: toResponseDTO(Payment payment, Invoice invoice)
  - [ ] Map all fields and compute invoice number, customer name
  - [ ] Use MapStruct or manual mapping as per project convention

- [ ] Create database migration script (AC: 7)
  - [ ] Create V3__create_payments_table.sql in backend/src/main/resources/db/migration/
  - [ ] CREATE TABLE payments with all fields matching Payment entity
  - [ ] Add PRIMARY KEY constraint on id
  - [ ] Add FOREIGN KEY constraint: invoice_id REFERENCES invoices(id)
  - [ ] Add CHECK constraint: amount > 0
  - [ ] Add CHECK constraint: payment_method IN ('CreditCard', 'BankTransfer', 'Check', 'Cash')
  - [ ] Add NOT NULL constraints on required fields
  - [ ] CREATE INDEX idx_payments_invoice_id ON payments(invoice_id)
  - [ ] CREATE INDEX idx_payments_payment_date ON payments(payment_date)
  - [ ] Add comments documenting table purpose and key constraints
  - [ ] Test migration runs successfully with Flyway

- [ ] Implement unit tests for Payment entity (AC: 6)
  - [ ] Create PaymentTest.java in src/test/java/features/payment/domain/
  - [ ] Test createPayment() factory method with valid inputs succeeds
  - [ ] Test createPayment() with null invoiceId throws exception
  - [ ] Test createPayment() with null/zero amount throws exception
  - [ ] Test createPayment() with negative amount throws InvalidPaymentException
  - [ ] Test createPayment() with null paymentMethod throws exception
  - [ ] Test createPayment() with future paymentDate throws exception
  - [ ] Test Payment entity persists correctly with JPA
  - [ ] Test equals() and hashCode() work correctly
  - [ ] Test audit fields (createdAt) are set on persist
  - [ ] Use JUnit 5 and AssertJ for assertions
  - [ ] Achieve >90% code coverage on Payment entity

- [ ] Implement unit tests for PaymentService (AC: 6)
  - [ ] Create PaymentServiceTest.java in src/test/java/features/payment/domain/
  - [ ] Mock InvoiceRepository with Mockito
  - [ ] Test validatePaymentAgainstInvoice() succeeds for valid payment
  - [ ] Test validatePaymentAgainstInvoice() throws exception when invoice is Draft
  - [ ] Test validatePaymentAgainstInvoice() throws exception when amount > balance
  - [ ] Test validatePaymentAgainstInvoice() allows payment equal to balance
  - [ ] Test validatePaymentAgainstInvoice() allows partial payment (amount < balance)
  - [ ] Test calculateNewBalance() returns correct result
  - [ ] Test shouldMarkInvoiceAsPaid() returns true when balance is zero
  - [ ] Test shouldMarkInvoiceAsPaid() returns true when balance is 0.001 (rounding)
  - [ ] Test shouldMarkInvoiceAsPaid() returns false when balance > 0.01
  - [ ] Use test data builders for Payment and Invoice objects
  - [ ] Achieve >90% code coverage on PaymentService

- [ ] Implement repository tests (AC: 4, 7)
  - [ ] Create PaymentRepositoryTest.java in src/test/java/features/payment/domain/
  - [ ] Use @DataJpaTest for integration testing
  - [ ] Test findByInvoiceId() returns all payments for invoice
  - [ ] Test findByInvoiceId() returns empty list when no payments
  - [ ] Test findByPaymentDateBetween() filters by date range correctly
  - [ ] Test findByPaymentMethod() filters by payment method
  - [ ] Test save() persists payment with all fields
  - [ ] Test foreign key constraint prevents invalid invoiceId
  - [ ] Test CHECK constraint prevents negative amounts
  - [ ] Test CHECK constraint validates payment_method enum values
  - [ ] Use TestContainers with PostgreSQL for realistic testing
  - [ ] Clean up test data after each test

- [ ] Add Payment domain to project documentation (AC: 1-8)
  - [ ] Update architecture.md Data Models section with Payment entity
  - [ ] Document Payment-Invoice relationship and constraints
  - [ ] Document PaymentService reconciliation logic
  - [ ] Add Payment to database schema documentation
  - [ ] Update ERD diagram to include Payment table and relationships
  - [ ] Document business rules for payment validation
  - [ ] Add code comments explaining complex validation logic
  - [ ] Ensure JavaDoc is complete for all public methods

## Dev Notes

### Previous Story Insights

**Story 2.5 Completion:**
Story 2.5 implemented the Invoice Management UI:
- Invoice list page with filtering, pagination, sorting
- Invoice detail view with print-friendly layout
- Send invoice functionality with confirmation dialog
- Copy invoice to create new draft
- Bulk actions menu (placeholders)
- URL state persistence for filters
- Responsive design (table on desktop, cards on mobile)
- Comprehensive component tests

**Story 2.1-2.3 Completion:**
Stories 2.1-2.3 established the Invoice domain:
- Invoice aggregate root with LineItem value objects
- Invoice lifecycle states: Draft → Sent → Paid
- CQRS separation: Commands and Queries
- InvoiceService for complex calculations
- Sequential invoice number generation
- Database schema with JSONB for line items
- Repository pattern with JPA implementation
- Comprehensive unit and integration tests

**Epic 1 Completion:**
Epic 1 established foundational patterns:
- Spring Boot 3.x backend with Java 17
- Domain-Driven Design with rich domain entities
- CQRS pattern with separate command/query handlers
- Repository pattern with JPA and PostgreSQL
- Vertical Slice Architecture organizing by feature
- JWT authentication with Spring Security
- Validation at multiple layers (controller, domain)
- Unit and integration testing with JUnit 5

### Data Models

**Payment Entity** [Source: architecture.md#Data Models]:
```java
@Entity
@Table(name = "payments")
public class Payment {
    @Id
    @GeneratedValue(generator = "UUID")
    private UUID id;

    @Column(name = "invoice_id", nullable = false)
    private UUID invoiceId;

    @Column(name = "payment_date", nullable = false)
    private LocalDate paymentDate;

    @Column(precision = 10, scale = 2, nullable = false)
    @Positive
    private BigDecimal amount;

    @Enumerated(EnumType.STRING)
    @Column(name = "payment_method", nullable = false)
    private PaymentMethod paymentMethod;

    @Column(length = 255)
    private String reference;

    @Column(columnDefinition = "TEXT")
    private String notes;

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;

    @Column(name = "created_by", nullable = false)
    private String createdBy;

    // Factory method for creating payments with validation
    public static Payment createPayment(
        UUID invoiceId,
        LocalDate paymentDate,
        BigDecimal amount,
        PaymentMethod paymentMethod,
        String reference,
        String notes,
        String createdBy
    ) {
        // Validation logic
        if (invoiceId == null) {
            throw new InvalidPaymentException("Invoice ID is required");
        }
        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new InvalidPaymentException("Payment amount must be positive");
        }
        if (paymentDate == null || paymentDate.isAfter(LocalDate.now())) {
            throw new InvalidPaymentException("Payment date cannot be in the future");
        }
        if (paymentMethod == null) {
            throw new InvalidPaymentException("Payment method is required");
        }
        if (createdBy == null || createdBy.isBlank()) {
            throw new InvalidPaymentException("Created by is required");
        }

        return new Payment(invoiceId, paymentDate, amount, paymentMethod, reference, notes, createdBy);
    }

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
    }
}
```

**PaymentMethod Enum** [Source: architecture.md#Data Models]:
```java
public enum PaymentMethod {
    CREDIT_CARD("Credit Card"),
    BANK_TRANSFER("Bank Transfer"),
    CHECK("Check"),
    CASH("Cash");

    private final String displayName;

    PaymentMethod(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() {
        return displayName;
    }
}
```

**TypeScript Interface** [Source: architecture.md#Data Models]:
```typescript
type PaymentMethod = 'CreditCard' | 'BankTransfer' | 'Check' | 'Cash';

interface Payment {
  id: string;
  invoiceId: string;
  paymentDate: Date;
  amount: number;
  paymentMethod: PaymentMethod;
  reference: string;
  notes?: string;
  createdAt: Date;
  createdBy: string;
}

interface RecordPaymentDTO {
  invoiceId: string;
  paymentDate: Date;
  amount: number;
  paymentMethod: PaymentMethod;
  reference: string;
  notes?: string;
}

interface PaymentResponseDTO extends Payment {
  invoiceNumber?: string;
  customerName?: string;
  remainingBalance?: number;
}
```

### API Specifications

**No API endpoints in this story** - This story focuses on domain model only.
API endpoints will be implemented in Story 3.2 (Commands) and Story 3.3 (Queries).

### Component Specifications

**PaymentService Domain Service** [Source: PRD Epic 3 Story 3.1 AC 5]:
- Location: backend/src/main/java/com/invoiceme/features/payment/domain/PaymentService.java
- Responsibility: Payment-invoice reconciliation business logic
- Key Methods:
  - `validatePaymentAgainstInvoice(Payment payment, Invoice invoice)` - Validates payment can be applied
  - `calculateNewBalance(Invoice invoice, BigDecimal paymentAmount)` - Calculates invoice balance after payment
  - `shouldMarkInvoiceAsPaid(BigDecimal newBalance)` - Determines if invoice should transition to Paid status
- Dependencies: InvoiceRepository
- Business Rules:
  - Payments can only be applied to Sent invoices (not Draft)
  - Payment amount cannot exceed invoice balance
  - Invoice marked as Paid when balance reaches zero (or within 0.01 for rounding)
  - Partial payments are allowed (amount < balance)

**PaymentRepository** [Source: PRD Epic 3 Story 3.1 AC 4]:
- Location: backend/src/main/java/com/invoiceme/features/payment/domain/PaymentRepository.java
- Extends: JpaRepository<Payment, UUID>
- Query Methods:
  - `findByInvoiceId(UUID invoiceId)` - Get all payments for an invoice
  - `findByIdAndInvoiceId(UUID id, UUID invoiceId)` - Get specific payment for invoice
  - `findByPaymentDateBetween(LocalDate start, LocalDate end)` - Filter by date range
  - `findByPaymentMethod(PaymentMethod method)` - Filter by payment method
- Follows repository pattern from Customer and Invoice domains

### File Locations

**Backend Files** [Source: architecture.md#Unified Project Structure]:
```
backend/src/main/java/com/invoiceme/features/payment/
├── domain/
│   ├── Payment.java                    # Payment entity with validation
│   ├── PaymentMethod.java              # Enum for payment methods
│   ├── PaymentRepository.java          # Repository interface
│   └── PaymentService.java             # Domain service for reconciliation
├── commands/
│   └── RecordPaymentDTO.java           # Command DTO (for Story 3.2)
└── queries/
    └── PaymentResponseDTO.java         # Query DTO (for Story 3.3)

backend/src/main/java/com/invoiceme/common/exceptions/
└── InvalidPaymentException.java        # Domain exception for payment validation

backend/src/main/resources/db/migration/
└── V3__create_payments_table.sql       # Flyway migration script

backend/src/test/java/com/invoiceme/features/payment/domain/
├── PaymentTest.java                    # Unit tests for Payment entity
├── PaymentServiceTest.java             # Unit tests for PaymentService
└── PaymentRepositoryTest.java          # Integration tests for repository
```

### Testing Requirements

**Testing Strategy** [Source: architecture.md#Tech Stack, PRD Technical Assumptions]:
- JUnit 5 for unit tests
- Mockito for mocking dependencies
- AssertJ for fluent assertions
- @DataJpaTest for repository integration tests
- TestContainers with PostgreSQL for realistic database testing
- Test data builders for Payment and Invoice objects
- Minimum 90% code coverage on domain logic

**Unit Test Structure for Payment Entity**:
```java
@DisplayName("Payment Entity Tests")
class PaymentTest {

    @Test
    @DisplayName("Should create payment with valid inputs")
    void shouldCreatePaymentWithValidInputs() {
        UUID invoiceId = UUID.randomUUID();
        LocalDate paymentDate = LocalDate.now();
        BigDecimal amount = new BigDecimal("100.00");
        PaymentMethod method = PaymentMethod.CREDIT_CARD;

        Payment payment = Payment.createPayment(
            invoiceId, paymentDate, amount, method,
            "REF-123", "Test payment", "user@example.com"
        );

        assertThat(payment).isNotNull();
        assertThat(payment.getInvoiceId()).isEqualTo(invoiceId);
        assertThat(payment.getAmount()).isEqualByComparingTo(amount);
        assertThat(payment.getPaymentMethod()).isEqualTo(method);
    }

    @Test
    @DisplayName("Should throw exception when amount is negative")
    void shouldThrowExceptionWhenAmountIsNegative() {
        UUID invoiceId = UUID.randomUUID();
        LocalDate paymentDate = LocalDate.now();
        BigDecimal negativeAmount = new BigDecimal("-50.00");

        assertThatThrownBy(() -> Payment.createPayment(
            invoiceId, paymentDate, negativeAmount,
            PaymentMethod.CASH, "REF", "Note", "user"
        ))
        .isInstanceOf(InvalidPaymentException.class)
        .hasMessageContaining("amount must be positive");
    }

    @Test
    @DisplayName("Should throw exception when payment exceeds invoice balance")
    void shouldThrowExceptionWhenPaymentExceedsBalance() {
        // Test will be in PaymentServiceTest
    }
}
```

**Unit Test Structure for PaymentService**:
```java
@DisplayName("PaymentService Tests")
class PaymentServiceTest {

    @Mock
    private InvoiceRepository invoiceRepository;

    @InjectMocks
    private PaymentService paymentService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    @DisplayName("Should validate payment against sent invoice successfully")
    void shouldValidatePaymentAgainstSentInvoice() {
        Invoice invoice = InvoiceTestBuilder.aInvoice()
            .withStatus(InvoiceStatus.SENT)
            .withTotalAmount(new BigDecimal("500.00"))
            .withBalance(new BigDecimal("500.00"))
            .build();

        Payment payment = PaymentTestBuilder.aPayment()
            .withAmount(new BigDecimal("200.00"))
            .build();

        assertDoesNotThrow(() ->
            paymentService.validatePaymentAgainstInvoice(payment, invoice)
        );
    }

    @Test
    @DisplayName("Should throw exception when payment applied to draft invoice")
    void shouldThrowExceptionWhenPaymentAppliedToDraftInvoice() {
        Invoice invoice = InvoiceTestBuilder.aInvoice()
            .withStatus(InvoiceStatus.DRAFT)
            .build();

        Payment payment = PaymentTestBuilder.aPayment()
            .withAmount(new BigDecimal("100.00"))
            .build();

        assertThatThrownBy(() ->
            paymentService.validatePaymentAgainstInvoice(payment, invoice)
        )
        .isInstanceOf(DomainException.class)
        .hasMessageContaining("Cannot apply payment to draft invoice");
    }

    @Test
    @DisplayName("Should throw exception when payment exceeds balance")
    void shouldThrowExceptionWhenPaymentExceedsBalance() {
        Invoice invoice = InvoiceTestBuilder.aInvoice()
            .withStatus(InvoiceStatus.SENT)
            .withBalance(new BigDecimal("100.00"))
            .build();

        Payment payment = PaymentTestBuilder.aPayment()
            .withAmount(new BigDecimal("150.00"))
            .build();

        assertThatThrownBy(() ->
            paymentService.validatePaymentAgainstInvoice(payment, invoice)
        )
        .isInstanceOf(DomainException.class)
        .hasMessageContaining("Payment amount exceeds invoice balance");
    }

    @Test
    @DisplayName("Should calculate new balance correctly")
    void shouldCalculateNewBalanceCorrectly() {
        Invoice invoice = InvoiceTestBuilder.aInvoice()
            .withBalance(new BigDecimal("500.00"))
            .build();

        BigDecimal paymentAmount = new BigDecimal("200.00");

        BigDecimal newBalance = paymentService.calculateNewBalance(invoice, paymentAmount);

        assertThat(newBalance).isEqualByComparingTo(new BigDecimal("300.00"));
    }

    @Test
    @DisplayName("Should mark invoice as paid when balance is zero")
    void shouldMarkInvoiceAsPaidWhenBalanceIsZero() {
        BigDecimal zeroBalance = BigDecimal.ZERO;

        boolean shouldMarkPaid = paymentService.shouldMarkInvoiceAsPaid(zeroBalance);

        assertThat(shouldMarkPaid).isTrue();
    }

    @Test
    @DisplayName("Should mark invoice as paid when balance is within rounding tolerance")
    void shouldMarkInvoiceAsPaidWhenBalanceWithinTolerance() {
        BigDecimal tinyBalance = new BigDecimal("0.005");

        boolean shouldMarkPaid = paymentService.shouldMarkInvoiceAsPaid(tinyBalance);

        assertThat(shouldMarkPaid).isTrue();
    }

    @Test
    @DisplayName("Should not mark invoice as paid when balance is significant")
    void shouldNotMarkInvoiceAsPaidWhenBalanceIsSignificant() {
        BigDecimal significantBalance = new BigDecimal("50.00");

        boolean shouldMarkPaid = paymentService.shouldMarkInvoiceAsPaid(significantBalance);

        assertThat(shouldMarkPaid).isFalse();
    }
}
```

### Technical Constraints

**Dependencies** [Source: architecture.md#Tech Stack]:
- Spring Boot 3.2.x
- Java 17
- Spring Data JPA
- PostgreSQL 15
- Hibernate for ORM
- Flyway for database migrations
- JUnit 5 for testing
- Mockito for mocking
- AssertJ for assertions
- TestContainers for integration tests

**Database Schema** [Source: architecture.md#Database Schema]:
```sql
-- Payments table
CREATE TABLE payments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    invoice_id UUID NOT NULL REFERENCES invoices(id),
    payment_date DATE NOT NULL,
    amount DECIMAL(10, 2) NOT NULL CHECK (amount > 0),
    payment_method VARCHAR(50) NOT NULL CHECK (payment_method IN ('CreditCard', 'BankTransfer', 'Check', 'Cash')),
    reference VARCHAR(255),
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by VARCHAR(255) NOT NULL
);

CREATE INDEX idx_payments_invoice_id ON payments(invoice_id);
CREATE INDEX idx_payments_payment_date ON payments(payment_date);
```

**Validation Rules** [Source: PRD Epic 3 Story 3.1 AC 3]:
- Payment amount must be positive (> 0)
- Payment amount cannot exceed invoice balance
- Payment can only be applied to Sent invoices (not Draft or already Paid)
- Payment date cannot be in future
- InvoiceId, paymentMethod, and createdBy are required fields
- Reference is optional but recommended for audit trail

**Domain-Driven Design Principles** [Source: architecture.md#Architectural Patterns]:
- Payment is an entity (has identity, mutable state)
- PaymentMethod is a value object (enum)
- Payment entity encapsulates validation logic
- PaymentService contains cross-aggregate business logic (Payment-Invoice reconciliation)
- Repository pattern abstracts data access
- Domain exceptions for business rule violations
- Factory method (createPayment) ensures valid construction

**Relationship with Invoice Domain** [Source: architecture.md#Data Models]:
- Payment has Many-to-One relationship with Invoice
- Payment references Invoice by invoiceId (foreign key)
- Payment does not directly modify Invoice (will be done in command handler in Story 3.2)
- PaymentService validates payment against Invoice balance
- Referential integrity enforced at database level (FK constraint)

### Coding Standards

**Critical Backend Rules** [Source: architecture.md#Coding Standards]:
- Domain Logic in Entities: Business rules belong in domain objects (Payment.createPayment validation)
- Transaction Boundaries: Will be handled at command handler level in Story 3.2 (not in this story)
- DTO Pattern: Separate DTOs for commands and queries (RecordPaymentDTO, PaymentResponseDTO)
- Validation Layers: Validate in domain (business rules) and controller (input validation)
- Immutable Entities: Payment has no setters, only getters (create via factory method)
- Repository Pattern: PaymentRepository interface in domain layer, JPA implementation by Spring Data

**Naming Conventions** [Source: architecture.md#Coding Standards]:
- Java Classes: PascalCase (Payment, PaymentService, PaymentRepository)
- Java Methods: camelCase (createPayment, validatePaymentAgainstInvoice)
- Database Tables: snake_case (payments, payment_method)
- DTOs: Suffix with DTO (RecordPaymentDTO, PaymentResponseDTO)
- Exceptions: Suffix with Exception (InvalidPaymentException)

**Java 17 Features** [Source: architecture.md#Tech Stack]:
- Use records for DTOs (RecordPaymentDTO)
- Use sealed classes if needed for domain modeling
- Use text blocks for SQL in tests
- Use var for local variables where type is obvious
- Use switch expressions for enum handling

**Vertical Slice Architecture** [Source: architecture.md#Architectural Patterns]:
- All Payment-related code in features/payment/ directory
- domain/ subdirectory: entities, value objects, repository interfaces, domain services
- commands/ subdirectory: command DTOs (for Story 3.2)
- queries/ subdirectory: query DTOs and read models (for Story 3.3)
- api/ subdirectory: controllers (for Stories 3.2 and 3.3)
- Self-contained: Payment slice depends on Invoice slice, but not vice versa

**Error Handling** [Source: PRD Epic 4 Story 4.2]:
- Domain exceptions for business rule violations (InvalidPaymentException)
- Extend RuntimeException or create custom hierarchy
- Include meaningful error messages explaining what went wrong
- Use specific exception types (not generic IllegalArgumentException)
- Log exceptions with context information

### Project Structure Notes

**Alignment with Existing Structure** [Verified from Story 2.5]:
The Payment domain follows the same structure as Customer and Invoice domains:
- features/{domain}/domain/ - Domain entities and repository interfaces
- features/{domain}/commands/ - Command DTOs and handlers
- features/{domain}/queries/ - Query DTOs and handlers
- features/{domain}/api/ - REST controllers
- common/exceptions/ - Shared exception types

**Database Migration Versioning**:
- V1__initial_schema.sql created Customer table (Story 1.1)
- V2__create_invoices_table.sql created Invoice table (Story 2.1)
- V3__create_payments_table.sql will create Payment table (this story)
- Sequential versioning ensures migrations run in order

**Test Data Builders**:
Create builder pattern for test data:
- PaymentTestBuilder for creating Payment test instances
- InvoiceTestBuilder already exists from Epic 2
- CustomerTestBuilder already exists from Epic 1
- Use fluent API: `PaymentTestBuilder.aPayment().withAmount(100).build()`

## Testing
- Unit tests for Payment entity validation logic
- Test Payment.createPayment() factory method with valid/invalid inputs
- Test payment amount validation (positive, non-zero)
- Test payment date validation (not in future)
- Test required field validation (invoiceId, paymentMethod, createdBy)
- Unit tests for PaymentService reconciliation logic
- Test validatePaymentAgainstInvoice() with various invoice states
- Test payment amount vs. invoice balance validation
- Test partial payment scenarios
- Test full payment scenarios (balance becomes zero)
- Test calculateNewBalance() correctness
- Test shouldMarkInvoiceAsPaid() with various balance values
- Integration tests for PaymentRepository
- Test findByInvoiceId() returns correct payments
- Test findByPaymentDateBetween() filters correctly
- Test findByPaymentMethod() filters correctly
- Test save() persists payment with all fields
- Test database constraints (FK, CHECK, NOT NULL)
- Use TestContainers with PostgreSQL for realistic testing
- Minimum 90% code coverage on Payment domain logic
- Use JUnit 5, Mockito, AssertJ
- Create test data builders for Payment and Invoice

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-11-08 | v1.0 | Initial story creation from PRD Epic 3 Story 3.1 | Claude (Story Agent) |

## Dev Agent Record

### Agent Model Used
Not yet implemented

### Debug Log References
None yet - will be populated during implementation

### Completion Notes List
None yet - will be populated during implementation

### File List
None yet - will be populated during implementation

## QA Results
Not yet reviewed
